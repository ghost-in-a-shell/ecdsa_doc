{"config":{"indexing":"full","lang":["en","ja"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-\\.]+"},"docs":[{"location":"","text":"MbedTLS ECDSA\u7b7e\u540d\u9a8c\u7b7e\u51fd\u6570\u89e3\u6790 \u5f00\u53d1\u677f\uff1a\u91ce\u706b\u9738\u5929\u864e STM32F407ZGT6 \u7269\u7406\u673a\u7cfb\u7edf\uff1aWindows10 \u7269\u7406\u673a\u67b6\u6784\uff1ax86_64 MbedTLS\u7248\u672c\uff1a2.16.2 ARM MDK\u7248\u672c\uff1akeil5.15 \u7f16\u8bd1\u5668\u7248\u672c\uff1aARMClang V5.05 update 2\uff08build 169\uff09 \u6ce8\uff1a\u4ee3\u7801\u4f4d\u7f6e https://github.com/ghost-in-a-shell/mbedtls-ecdsa-ARM/tree/main","title":"\u4e3b\u9875"},{"location":"#mbedtls-ecdsa","text":"\u5f00\u53d1\u677f\uff1a\u91ce\u706b\u9738\u5929\u864e STM32F407ZGT6 \u7269\u7406\u673a\u7cfb\u7edf\uff1aWindows10 \u7269\u7406\u673a\u67b6\u6784\uff1ax86_64 MbedTLS\u7248\u672c\uff1a2.16.2 ARM MDK\u7248\u672c\uff1akeil5.15 \u7f16\u8bd1\u5668\u7248\u672c\uff1aARMClang V5.05 update 2\uff08build 169\uff09 \u6ce8\uff1a\u4ee3\u7801\u4f4d\u7f6e https://github.com/ghost-in-a-shell/mbedtls-ecdsa-ARM/tree/main","title":"MbedTLS ECDSA\u7b7e\u540d\u9a8c\u7b7e\u51fd\u6570\u89e3\u6790"},{"location":"concl/","text":"\u76ee\u524d\u5df2\u77e5\u53ef\u4f18\u5316\u4f4d\u7f6e\u603b\u7ed3 \u7b7e\u540d\u65f6\u989d\u5916\u7684\u968f\u673a\u6570t t (e + rd) / (kt) mod n t (e + rd) / (kt) mod n \u692d\u5706\u66f2\u7ebf\u4e58\u6cd5\u4e2dmxz\u65b9\u6cd5\u65f6\u521d\u59cb\u70b9\u968f\u673a\u5316 ecp_mul_mxz \u692d\u5706\u66f2\u7ebf\u4e58\u6cd5\u4e2dmxz\u65b9\u6cd5montgomery ladder\u66ff\u6362\u4e3a\u666e\u901a\u5b9e\u73b0 ecp_mul_mxz \u692d\u5706\u66f2\u7ebf\u4e58\u6cd5\u4e2dcomb\u65b9\u6cd5\u4f18\u5316\uff0c\u4f8b\u5982\u53bb\u6389\u5b89\u5168\u8d4b\u503c mbedtls_mpi_safe_cond_assign","title":"\u603b\u7ed3"},{"location":"concl/#_1","text":"\u7b7e\u540d\u65f6\u989d\u5916\u7684\u968f\u673a\u6570t t (e + rd) / (kt) mod n t (e + rd) / (kt) mod n \u692d\u5706\u66f2\u7ebf\u4e58\u6cd5\u4e2dmxz\u65b9\u6cd5\u65f6\u521d\u59cb\u70b9\u968f\u673a\u5316 ecp_mul_mxz \u692d\u5706\u66f2\u7ebf\u4e58\u6cd5\u4e2dmxz\u65b9\u6cd5montgomery ladder\u66ff\u6362\u4e3a\u666e\u901a\u5b9e\u73b0 ecp_mul_mxz \u692d\u5706\u66f2\u7ebf\u4e58\u6cd5\u4e2dcomb\u65b9\u6cd5\u4f18\u5316\uff0c\u4f8b\u5982\u53bb\u6389\u5b89\u5168\u8d4b\u503c mbedtls_mpi_safe_cond_assign","title":"\u76ee\u524d\u5df2\u77e5\u53ef\u4f18\u5316\u4f4d\u7f6e\u603b\u7ed3"},{"location":"sign/ecdsasign/","text":"\u5165\u53e3\u51fd\u6570\uff1ambedtls_ecdsa_sign\uff08ecdsa.c 384\uff09 \u51fd\u6570\u8f93\u5165 grp\uff1a\u692d\u5706\u66f2\u7ebf\u7fa4\u6307\u9488 r\u3001s\uff1a\u7528\u4e8e\u5b58\u50a8\u7b7e\u540d\u7ed3\u679c d\uff1aECDSA\u79c1\u94a5 buf\uff1a\u6b64\u5904\u8f93\u5165\u4e3a\u6d88\u606fmsg\u7684\u54c8\u5e0c\u503c blen\uff1a\u54c8\u5e0c\u503c\u957f\u5ea6 f_rng\uff1a \u968f\u673a\u6570\u751f\u6210\u51fd\u6570 p_rng\uff1a\u4f2a\u968f\u673a\u6570\u751f\u6210\u5668\u4e0a\u4e0b\u6587 \u51fd\u6570\u8f93\u51fa \u51fd\u6570\u8fd4\u56de\u4e00\u4e2a\u72b6\u6001\u503c\uff0c\u8868\u793a\u6210\u529f\u6216\u5931\u8d25 \u540c\u65f6\u751f\u6210\u7b7e\u540dr\u548cs \u51fd\u6570\u6d41\u7a0b \u70b9\u51fb\u6d41\u7a0b\u56fe\u8df3\u8f6c\u5bf9\u5e94\u51fd\u6570 graph TB F[mbedtls_ecdsa_sign\u51fd\u6570] A[\u8f93\u5165] -->B(ECDSA_VALIDATE_RET) B -.-> C(ECDSA_VALIDATE_RET) C --> D(ecdsa_sign_restartable) D --> E[\u8f93\u51fa] click B \"../../tools/ECDSA_VALIDATE_RET\" click C \"../../tools/ECDSA_VALIDATE_RET\" click F \"../../tools/ECDSA_VALIDATE_RET\" click D \"../signrestartable\" \u51fd\u6570\u4ee3\u7801 int mbedtls_ecdsa_sign ( mbedtls_ecp_group * grp , mbedtls_mpi * r , mbedtls_mpi * s , const mbedtls_mpi * d , const unsigned char * buf , size_t blen , int ( * f_rng )( void * , unsigned char * , size_t ), void * p_rng ) { ECDSA_VALIDATE_RET ( grp != NULL ); ECDSA_VALIDATE_RET ( r != NULL ); ECDSA_VALIDATE_RET ( s != NULL ); ECDSA_VALIDATE_RET ( d != NULL ); ECDSA_VALIDATE_RET ( f_rng != NULL ); ECDSA_VALIDATE_RET ( buf != NULL || blen == 0 ); return ( ecdsa_sign_restartable ( grp , r , s , d , buf , blen , f_rng , p_rng , NULL ) ); } \u51fd\u6570\u8bf4\u660e 1.\u9996\u5148\u4f7f\u7528ECDSA_VALIDATE_RET\u51fd\u6570\u68c0\u67e5\u5404\u4e2a\u53c2\u6570\u662f\u5426\u5408\u6cd5\uff0c\u7136\u800c\u8fd9\u91cc\u7684ECDSA_VALIDATE_RET\u51fd\u6570\u5b9e\u5219\u8c03\u7528 #define MBEDTLS_INTERNAL_VALIDATE_RET( cond, ret ) do { } while( 0 ) \u5e76\u6ca1\u6709\u4efb\u4f55\u529f\u80fd\u3002 2.\u5c06\u53c2\u6570\u4f20\u9012\u7ed9ecdsa_sign_restartable\u51fd\u6570\u8fdb\u4e00\u6b65\u6267\u884c\u3002\u8fd9\u4e2a\u51fd\u6570\u76f8\u5f53\u4e8e\u9ed8\u8ba4\u4e0d\u5f00\u542frestartable\u6a21\u5f0f\u7684\u7b7e\u540d\u51fd\u6570\u3002","title":"mbedtls_ecdsa_sign"},{"location":"sign/ecdsasign/#mbedtls_ecdsa_signecdsac-384","text":"","title":"\u5165\u53e3\u51fd\u6570\uff1ambedtls_ecdsa_sign\uff08ecdsa.c 384\uff09"},{"location":"sign/ecdsasign/#_1","text":"grp\uff1a\u692d\u5706\u66f2\u7ebf\u7fa4\u6307\u9488 r\u3001s\uff1a\u7528\u4e8e\u5b58\u50a8\u7b7e\u540d\u7ed3\u679c d\uff1aECDSA\u79c1\u94a5 buf\uff1a\u6b64\u5904\u8f93\u5165\u4e3a\u6d88\u606fmsg\u7684\u54c8\u5e0c\u503c blen\uff1a\u54c8\u5e0c\u503c\u957f\u5ea6 f_rng\uff1a \u968f\u673a\u6570\u751f\u6210\u51fd\u6570 p_rng\uff1a\u4f2a\u968f\u673a\u6570\u751f\u6210\u5668\u4e0a\u4e0b\u6587","title":"\u51fd\u6570\u8f93\u5165"},{"location":"sign/ecdsasign/#_2","text":"\u51fd\u6570\u8fd4\u56de\u4e00\u4e2a\u72b6\u6001\u503c\uff0c\u8868\u793a\u6210\u529f\u6216\u5931\u8d25 \u540c\u65f6\u751f\u6210\u7b7e\u540dr\u548cs","title":"\u51fd\u6570\u8f93\u51fa"},{"location":"sign/ecdsasign/#_3","text":"\u70b9\u51fb\u6d41\u7a0b\u56fe\u8df3\u8f6c\u5bf9\u5e94\u51fd\u6570 graph TB F[mbedtls_ecdsa_sign\u51fd\u6570] A[\u8f93\u5165] -->B(ECDSA_VALIDATE_RET) B -.-> C(ECDSA_VALIDATE_RET) C --> D(ecdsa_sign_restartable) D --> E[\u8f93\u51fa] click B \"../../tools/ECDSA_VALIDATE_RET\" click C \"../../tools/ECDSA_VALIDATE_RET\" click F \"../../tools/ECDSA_VALIDATE_RET\" click D \"../signrestartable\"","title":"\u51fd\u6570\u6d41\u7a0b"},{"location":"sign/ecdsasign/#_4","text":"int mbedtls_ecdsa_sign ( mbedtls_ecp_group * grp , mbedtls_mpi * r , mbedtls_mpi * s , const mbedtls_mpi * d , const unsigned char * buf , size_t blen , int ( * f_rng )( void * , unsigned char * , size_t ), void * p_rng ) { ECDSA_VALIDATE_RET ( grp != NULL ); ECDSA_VALIDATE_RET ( r != NULL ); ECDSA_VALIDATE_RET ( s != NULL ); ECDSA_VALIDATE_RET ( d != NULL ); ECDSA_VALIDATE_RET ( f_rng != NULL ); ECDSA_VALIDATE_RET ( buf != NULL || blen == 0 ); return ( ecdsa_sign_restartable ( grp , r , s , d , buf , blen , f_rng , p_rng , NULL ) ); }","title":"\u51fd\u6570\u4ee3\u7801"},{"location":"sign/ecdsasign/#_5","text":"1.\u9996\u5148\u4f7f\u7528ECDSA_VALIDATE_RET\u51fd\u6570\u68c0\u67e5\u5404\u4e2a\u53c2\u6570\u662f\u5426\u5408\u6cd5\uff0c\u7136\u800c\u8fd9\u91cc\u7684ECDSA_VALIDATE_RET\u51fd\u6570\u5b9e\u5219\u8c03\u7528 #define MBEDTLS_INTERNAL_VALIDATE_RET( cond, ret ) do { } while( 0 ) \u5e76\u6ca1\u6709\u4efb\u4f55\u529f\u80fd\u3002 2.\u5c06\u53c2\u6570\u4f20\u9012\u7ed9ecdsa_sign_restartable\u51fd\u6570\u8fdb\u4e00\u6b65\u6267\u884c\u3002\u8fd9\u4e2a\u51fd\u6570\u76f8\u5f53\u4e8e\u9ed8\u8ba4\u4e0d\u5f00\u542frestartable\u6a21\u5f0f\u7684\u7b7e\u540d\u51fd\u6570\u3002","title":"\u51fd\u6570\u8bf4\u660e"},{"location":"sign/signrestartable/","text":"restartable\u5165\u53e3\u51fd\u6570\uff1aecdsa_sign_restartable\uff08ecdsa.c 253\uff09 \u51fd\u6570\u8f93\u5165 grp\uff1a\u692d\u5706\u66f2\u7ebf\u7fa4\u6307\u9488 r\u3001s\uff1a\u7528\u4e8e\u5b58\u50a8\u7b7e\u540d\u7ed3\u679c d\uff1aECDSA\u79c1\u94a5 buf\uff1a\u6b64\u5904\u8f93\u5165\u4e3a\u6d88\u606fmsg\u7684\u54c8\u5e0c\u503c blen\uff1a\u54c8\u5e0c\u503c\u957f\u5ea6 f_rng\uff1a \u968f\u673a\u6570\u751f\u6210\u51fd\u6570 p_rng\uff1a\u4f2a\u968f\u673a\u6570\u751f\u6210\u5668\u4e0a\u4e0b\u6587 restartable: \u53ef\u4ee5\u63a7\u5236\u662f\u5426\u5f00\u542frestartable\u6a21\u5f0f\uff0c\u5982\u679c\u4e3aNULL\u5219\u5173\u95ed\uff0c\u5982\u679c\u63d0\u4f9b\u5bf9\u5e94\u7684\u4e0a\u4e0b\u6587\u53ef\u4ee5\u5f00\u542f\uff0c\u652f\u6301\u4e2d\u65ad\u548c\u7ee7\u7eed\u6267\u884c\u3002 \u51fd\u6570\u8f93\u51fa \u51fd\u6570\u8fd4\u56de\u4e00\u4e2a\u72b6\u6001\u503c\uff0c\u8868\u793a\u6210\u529f\u6216\u5931\u8d25 \u540c\u65f6\u751f\u6210\u7b7e\u540dr\u548cs \u51fd\u6570\u6d41\u7a0b \u70b9\u51fb\u6d41\u7a0b\u56fe\u8df3\u8f6c\u5bf9\u5e94\u51fd\u6570 graph TB Z[ecdsa_sign_restartable\u51fd\u6570] A[\u8f93\u5165] -->B(\u5b9a\u4e49\u53d8\u91cf,\u68c0\u67e5\u5408\u6cd5\u6027,\u521d\u59cb\u5316\u7ed3\u6784\u4f53) B --> C(mbedtls_ecp_gen_privkey\u751f\u6210\u968f\u673a\u6570k) subgraph \u5faa\u73af \u76f4\u5230\u751f\u6210\u7684\u7b7e\u540d\u975e\u96f6 \u6700\u591a\u5c1d\u8bd510\u6b21 subgraph \u5faa\u73af \u76f4\u5230\u751f\u6210\u7684r\u975e\u96f6 \u6700\u591a\u5c1d\u8bd510\u6b21 C --> D(mbedtls_ecp_mul_restartable) D --> E(mbedtls_mpi_mod_mpi\u5bf9r\u7684\u6a2a\u5750\u6807\u53d6\u6a21) end E --> G(restartable\u6a21\u5f0f\u5b58\u50a8\u951a\u70b9) G --> H(mbedtls_ecp_gen_privkey\u751f\u6210\u968f\u673a\u6570t) H --> I(mbedtls_mpi_mul_mpi\u8ba1\u7b97d*r) I --> J(mbedtls_mpi_add_mpi\u8ba1\u7b97a=e+d*r) J --> K(mbedtls_mpi_mul_mpi\u8ba1\u7b97t*a) K --> P(mbedtls_mpi_mul_mpi\u8ba1\u7b97k*t) P --> L(mbedtls_mpi_inv_mod\u8ba1\u7b97\u6a21N\u7684\u9006) L --> M(mbedtls_mpi_mul_mpi\u8ba1\u7b97\u672a\u53d6\u6a21\u7684\u7b7e\u540ds) M --> N(mbedtls_mpi_mod_mpi\u5bf9N\u53d6\u6a21) end N --> O(\u8f93\u51fa) click C \"../../tools/mbedtls_ecp_gen_privkey\" click E \"../../tools/mpi\" click H \"../../tools/mbedtls_ecp_gen_privkey\" click I \"../../tools/mpi\" click J \"../../tools/mpi\" click K \"../../tools/mpi\" click P \"../../tools/mpi\" click L \"../../tools/mpi\" click M \"../../tools/mpi\" click N \"../../tools/mpi\" click F \"../../tools/ECDSA_VALIDATE_RET\" click D \"../../tools/mbedtls_ecp_mul_restartable\" \u51fd\u6570\u4ee3\u7801 static int ecdsa_sign_restartable ( mbedtls_ecp_group * grp , mbedtls_mpi * r , mbedtls_mpi * s , const mbedtls_mpi * d , const unsigned char * buf , size_t blen , int ( * f_rng )( void * , unsigned char * , size_t ), void * p_rng , mbedtls_ecdsa_restart_ctx * rs_ctx ) { int ret , key_tries , sign_tries ; int * p_sign_tries = & sign_tries , * p_key_tries = & key_tries ; mbedtls_ecp_point R ; mbedtls_mpi k , e , t ; mbedtls_mpi * pk = & k , * pr = r ; /* Fail cleanly on curves such as Curve25519 that can't be used for ECDSA */ if ( grp -> N . p == NULL ) return ( MBEDTLS_ERR_ECP_BAD_INPUT_DATA ); /* Make sure d is in range 1..n-1 */ if ( mbedtls_mpi_cmp_int ( d , 1 ) < 0 || mbedtls_mpi_cmp_mpi ( d , & grp -> N ) >= 0 ) return ( MBEDTLS_ERR_ECP_INVALID_KEY ); mbedtls_ecp_point_init ( & R ); mbedtls_mpi_init ( & k ); mbedtls_mpi_init ( & e ); mbedtls_mpi_init ( & t ); ECDSA_RS_ENTER ( sig ); #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> sig != NULL ) { /* redirect to our context */ p_sign_tries = & rs_ctx -> sig -> sign_tries ; p_key_tries = & rs_ctx -> sig -> key_tries ; pk = & rs_ctx -> sig -> k ; pr = & rs_ctx -> sig -> r ; /* jump to current step */ if ( rs_ctx -> sig -> state == ecdsa_sig_mul ) goto mul ; if ( rs_ctx -> sig -> state == ecdsa_sig_modn ) goto modn ; } #endif /* MBEDTLS_ECP_RESTARTABLE */ * p_sign_tries = 0 ; do { if ( * p_sign_tries ++ > 10 ) { ret = MBEDTLS_ERR_ECP_RANDOM_FAILED ; goto cleanup ; } /* * Steps 1-3: generate a suitable ephemeral keypair * and set r = xR mod n */ * p_key_tries = 0 ; do { if ( * p_key_tries ++ > 10 ) { ret = MBEDTLS_ERR_ECP_RANDOM_FAILED ; goto cleanup ; } MBEDTLS_MPI_CHK ( mbedtls_ecp_gen_privkey ( grp , pk , f_rng , p_rng ) ); #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> sig != NULL ) rs_ctx -> sig -> state = ecdsa_sig_mul ; mul : #endif MBEDTLS_MPI_CHK ( mbedtls_ecp_mul_restartable ( grp , & R , pk , & grp -> G , f_rng , p_rng , ECDSA_RS_ECP ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mod_mpi ( pr , & R . X , & grp -> N ) ); } while ( mbedtls_mpi_cmp_int ( pr , 0 ) == 0 ); #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> sig != NULL ) rs_ctx -> sig -> state = ecdsa_sig_modn ; modn : #endif /* * Accounting for everything up to the end of the loop * (step 6, but checking now avoids saving e and t) */ ECDSA_BUDGET ( MBEDTLS_ECP_OPS_INV + 4 ); /* * Step 5: derive MPI from hashed message */ MBEDTLS_MPI_CHK ( derive_mpi ( grp , & e , buf , blen ) ); /* * Generate a random value to blind inv_mod in next step, * avoiding a potential timing leak. */ MBEDTLS_MPI_CHK ( mbedtls_ecp_gen_privkey ( grp , & t , f_rng , p_rng ) ); /* * Step 6: compute s = (e + r * d) / k = t (e + rd) / (kt) mod n */ MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( s , pr , d ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_add_mpi ( & e , & e , s ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( & e , & e , & t ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( pk , pk , & t ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_inv_mod ( s , pk , & grp -> N ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( s , s , & e ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mod_mpi ( s , s , & grp -> N ) ); } while ( mbedtls_mpi_cmp_int ( s , 0 ) == 0 ); #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> sig != NULL ) mbedtls_mpi_copy ( r , pr ); #endif cleanup : mbedtls_ecp_point_free ( & R ); mbedtls_mpi_free ( & k ); mbedtls_mpi_free ( & e ); mbedtls_mpi_free ( & t ); ECDSA_RS_LEAVE ( sig ); return ( ret ); } \u51fd\u6570\u8bf4\u660e \u8fdb\u884cECDSA\u7b7e\u540d \u5bf9\u7167ECDSA\u7b7e\u540d\u6d41\u7a0b\uff1a \u7b2c\u4e00\u6b65 \uff0c\u751f\u6210\u968f\u673a\u7684k \u7b2c\u4e8c\u6b65 \uff0c\u8ba1\u7b97R=k*G\uff0cG\u4e3a\u57fa\u70b9\u3002\u4ee4r=R.x\uff0c\u4e3aR\u7684\u6a2a\u5750\u6807 \u7b2c\u4e09\u6b65 \uff0c\u8ba1\u7b97z=H(msg) \u7b2c\u56db\u6b65 \uff0c\u8ba1\u7b97s=(z+r*d)/k (modN) \u6700\u540e\u5f97\u5230 \u7b7e\u540d\uff08r,s\uff09 \u4ee3\u7801\u5206\u6790\uff1a\u987a\u5e8f\u5206\u6790\u51fd\u6570\u529f\u80fd 1.\u5b9a\u4e49\u53d8\u91cf\uff0c\u5176\u4e2dR\u3001k\u3001r\u4e0e\u4e0a\u9762\u6d41\u7a0b\u4e2d\u7684\u5bf9\u5e94\u53d8\u91cf\u76f8\u5bf9\u5e94 sign_tries\u7b49\u53d8\u91cf\u5b9a\u4e49\u4e86\u5c1d\u8bd5\u6b21\u6570\u4e0a\u9650 int ret , key_tries , sign_tries ; int * p_sign_tries = & sign_tries , * p_key_tries = & key_tries ; mbedtls_ecp_point R ; mbedtls_mpi k , e , t ; mbedtls_mpi * pk = & k , * pr = r ; 2.\u68c0\u67e5\u53d8\u91cf\u662f\u5426\u5408\u6cd5\uff0c\u68c0\u67e5\u4e86\u692d\u5706\u66f2\u7ebf\u662f\u5426\u53ef\u4ee5\u7528\u4e8eECDSA\uff0c\u79c1\u94a5d\u662f\u5426\u57281\u5230n-1\u7684\u5408\u6cd5\u8303\u56f4\u5185 /* Fail cleanly on curves such as Curve25519 that can't be used for ECDSA */ if ( grp -> N . p == NULL ) return ( MBEDTLS_ERR_ECP_BAD_INPUT_DATA ); /* Make sure d is in range 1..n-1 */ if ( mbedtls_mpi_cmp_int ( d , 1 ) < 0 || mbedtls_mpi_cmp_mpi ( d , & grp -> N ) >= 0 ) return ( MBEDTLS_ERR_ECP_INVALID_KEY ); 3.\u521d\u59cb\u5316\u7ed3\u6784\u4f53 mbedtls_ecp_point_init ( & R ); mbedtls_mpi_init ( & k ); mbedtls_mpi_init ( & e ); mbedtls_mpi_init ( & t ); 4.restart\u6a21\u5f0f\u4fdd\u5b58\u4e0a\u4e0b\u6587 \u5982\u679c\u51fd\u6570\u8f93\u5165\u4e86restart\u4e0a\u4e0b\u6587\uff0c\u590d\u539f\u72b6\u6001\uff0c\u5305\u62ec\u5c1d\u8bd5\u6b21\u6570\u548c\u5df2\u7ecf\u751f\u6210\u7684k\u548cr \u4e4b\u540e\u6839\u636e\u5b58\u50a8\u7684\u6b65\u9aa4\u8df3\u8f6c\u5230\u5bf9\u5e94\u7684\u4f4d\u7f6e 5. \u4e3b\u4f53\u4ee3\u7801-\u5916\u5c42\u5faa\u73af\uff1a \u5c1d\u8bd5\u751f\u6210\u7b7e\u540d\uff0c\u5982\u679c\u7b7e\u540d\u4e3a0\u5219\u91cd\u65b0\u751f\u6210\uff0c\u6700\u591a\u670910\u6b21\u673a\u4f1a\uff0c\u8d85\u8fc7\u5219\u62a5\u9519\u8fd4\u56de \u6ce8\uff1ambedtls_mpi_cmp_int\u51fd\u6570\u5927\u4e8e\u65f6\u8fd4\u56de1\uff0c\u5c0f\u4e8e\u8fd4\u56de-1\uff0c\u76f8\u7b49\u8fd4\u56de0 * p_sign_tries = 0 ; do { if ( * p_sign_tries ++ > 10 ) { ret = MBEDTLS_ERR_ECP_RANDOM_FAILED ; goto cleanup ; } ... } while ( mbedtls_mpi_cmp_int ( s , 0 ) == 0 ); 6. \u4e3b\u4f53\u4ee3\u7801-\u5faa\u73af\u4f53\u7b2c\u4e00\u90e8\u5206\uff1a \u751f\u6210k\u548c\u5bf9\u5e94\u7684r \u7c7b\u4f3c\u5730\uff0c\u5c1d\u8bd5\u6700\u591a10\u6b21\uff0c\u76f4\u5230\u751f\u6210\u7684r\uff08\u4ee3\u7801\u4e2d\u7684pr\uff09\u975e\u96f6 \u5176\u4e2dMBEDTLS_MPI_CHK\uff08f\uff09\u51fd\u6570\u68c0\u67e5\u62ec\u53f7\u5185\u51fd\u6570f\u7684\u8fd4\u56de\u503c\uff0c\u5982\u679c\u8fd4\u56de\u503c\u975e\u96f6\uff08\u6b63\u5e38\u6267\u884c\u65f6\u8fd4\u56de0\uff09\uff0c\u5219\u62a5\u9519\u8fd4\u56de\uff0c\u4e0d\u5f71\u54cdf\u51fd\u6570\u7684\u6267\u884c \u5faa\u73af\u5185\u9996\u5148\u8c03\u7528\u4e86mbedtls_ecp_gen_privkey\u51fd\u6570\uff0c\u8fd9\u4e2a\u51fd\u6570\u7528\u6765\u751f\u6210\u6307\u5b9a\u957f\u5ea6\u7684\u968f\u673a\u6570\uff0c\u65e2\u53ef\u4ee5\u751f\u6210ECDSA\u7684\u79c1\u94a5\uff0c\u4e5f\u53ef\u4ee5\u5728\u8fd9\u91cc\u7528\u4e8e\u7b7e\u540d\u7684\u968f\u673a\u6570k\uff08\u4ee3\u7801\u4e2d\u7684pk\uff09\uff0c\u4f7f\u7528\u968f\u673a\u6570\u751f\u6210\u51fd\u6570\u548c\u4f2a\u968f\u673a\u6570\u751f\u6210\u4e0a\u4e0b\u6587\u751f\u6210\u968f\u673a\u6570\u3002 \u751f\u6210\u4e86\u968f\u673a\u7684k\uff0c\u8fd9\u91cc\u5982\u679c\u5f00\u542f\u4e86restart\u6a21\u5f0f\uff0c\u5219\u8fdb\u884c\u72b6\u6001\u5b58\u50a8rs_ctx->sig->state = ecdsa_sig_mul\uff0c\u540c\u65f6\u65ad\u70b9\u7ee7\u7eed\u6267\u884c\u65f6\u4e5f\u4ece\u8fd9\u4e00\u53e5\u4e0b\u9762\u7684mul\uff1a\u540e\u5f00\u59cb\u6267\u884c \u4e4b\u540e\u8c03\u7528mbedtls_ecp_mul_restartable\u51fd\u6570\u8ba1\u7b97R=k*G \u6700\u540e\u8c03\u7528mbedtls_mpi_mod_mpi\u51fd\u6570\u5c06R\u7684\u6a2a\u5750\u6807\u5bf9N\u53d6\u6a21 * p_key_tries = 0 ; do { if ( * p_key_tries ++ > 10 ) { ret = MBEDTLS_ERR_ECP_RANDOM_FAILED ; goto cleanup ; } MBEDTLS_MPI_CHK ( mbedtls_ecp_gen_privkey ( grp , pk , f_rng , p_rng ) ); #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> sig != NULL ) rs_ctx -> sig -> state = ecdsa_sig_mul ; mul : #endif MBEDTLS_MPI_CHK ( mbedtls_ecp_mul_restartable ( grp , & R , pk , & grp -> G , f_rng , p_rng , ECDSA_RS_ECP ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mod_mpi ( pr , & R . X , & grp -> N ) ); } while ( mbedtls_mpi_cmp_int ( pr , 0 ) == 0 ); 7. \u4e3b\u4f53\u4ee3\u7801-\u5faa\u73af\u4f53\u7b2c\u4e8c\u90e8\u5206\uff1a \u8fd9\u91cc\u5982\u679c\u5f00\u542f\u4e86restart\u6a21\u5f0f\uff0c\u5219\u8fdb\u884c\u72b6\u6001\u5b58\u50a8rs_ctx->sig->state = ecdsa_sig_modn\uff0c\u540c\u65f6\u65ad\u70b9\u7ee7\u7eed\u6267\u884c\u65f6\u4e5f\u4ece\u8fd9\u4e00\u53e5\u4e0b\u9762\u7684modn\uff1a\u540e\u5f00\u59cb\u6267\u884c #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> sig != NULL ) rs_ctx -> sig -> state = ecdsa_sig_modn ; modn : 8. \u4e3b\u4f53\u4ee3\u7801-\u5faa\u73af\u4f53\u7b2c\u4e09\u90e8\u5206 \uff1a\u8ba1\u7b97\u53e6\u4e00\u90e8\u5206\u7b7e\u540ds ECDSA_BUDGET\u4e3a\u4e00\u4e2a\u7a7a\u7684\u5b8f\uff0c\u6ca1\u6709\u4f5c\u7528 #define ECDSA_BUDGET( ops ) /* no-op; for compatibility */ \u4e4b\u540e\u7684derive_mpi\u4ece\u9884\u5148\u751f\u6210\u7684\u54c8\u5e0cbuf\u751f\u6210\u4e00\u4e2a\u5927\u6574\u6570 mbedtls_ecp_gen_privkey\u4e0e\u4e4b\u524d\u76f8\u540c\uff0c\u751f\u6210\u4e00\u4e2a\u968f\u673a\u7684t t\u7684\u4f5c\u7528\uff1a\u4e3a\u4e86\u907f\u514d\u4f7f\u7528\u76f8\u540c\u7684\u968f\u673a\u6570\u800c\u5bfc\u81f4\u79c1\u94a5\u6cc4\u9732\uff0c\u9700\u8981\u4f7f\u7528\u4e00\u4e2a\u79f0\u4e3a\u201c\u7b7e\u540d\u76f2\u5316\u56e0\u5b50\u201d\uff08blinding factor\uff09\u7684\u968f\u673a\u6570\u6765\u76f2\u5316\u7b7e\u540d\u8fc7\u7a0b\u3002\u5728\u4e0a\u8ff0\u4ee3\u7801\u4e2d\uff0ct \u5c31\u662f\u4e00\u4e2a\u7b7e\u540d\u76f2\u5316\u56e0\u5b50\uff0c\u5b83\u662f\u901a\u8fc7\u8c03\u7528 mbedtls_ecp_gen_privkey \u51fd\u6570\u751f\u6210\u7684\u4e00\u4e2a\u968f\u673a\u6570\u3002\u751f\u6210\u968f\u673a\u6570\u7684\u8fc7\u7a0b\u662f\u4e3a\u4e86\u9632\u6b62\u4f7f\u7528\u76f8\u540c\u7684\u968f\u673a\u6570\u8fdb\u884c\u7b7e\u540d\u800c\u5bfc\u81f4\u79c1\u94a5\u6cc4\u9732\uff0c\u56e0\u4e3a\u6b64\u65f6\u653b\u51fb\u8005\u53ef\u80fd\u4f1a\u901a\u8fc7\u591a\u6b21\u89c2\u5bdf\u7b7e\u540d\u7ed3\u679c\u6765\u8ba1\u7b97\u51fa\u79c1\u94a5\u3002 \u4e4b\u540e\u7684\u4e00\u8fde\u4e32\u8ba1\u7b97\u4e3a\u8ba1\u7b97t (e + rd) / (kt) mod n \u7684\u8fc7\u7a0b ECDSA_BUDGET ( MBEDTLS_ECP_OPS_INV + 4 ); /* * Step 5: derive MPI from hashed message */ MBEDTLS_MPI_CHK ( derive_mpi ( grp , & e , buf , blen ) ); /* * Generate a random value to blind inv_mod in next step, * avoiding a potential timing leak. */ MBEDTLS_MPI_CHK ( mbedtls_ecp_gen_privkey ( grp , & t , f_rng , p_rng ) ); /* * Step 6: compute s = (e + r * d) / k = t (e + rd) / (kt) mod n */ MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( s , pr , d ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_add_mpi ( & e , & e , s ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( & e , & e , & t ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( pk , pk , & t ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_inv_mod ( s , pk , & grp -> N ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( s , s , & e ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mod_mpi ( s , s , & grp -> N ) ); 9.\u51fd\u6570\u7ed3\u5c3e\u90e8\u5206\uff0c\u5b58\u50a8\u72b6\u6001\u3001\u91ca\u653e\u7a7a\u95f4 #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> sig != NULL ) mbedtls_mpi_copy ( r , pr ); #endif cleanup : mbedtls_ecp_point_free ( & R ); mbedtls_mpi_free ( & k ); mbedtls_mpi_free ( & e ); mbedtls_mpi_free ( & t ); ECDSA_RS_LEAVE ( sig ); return ( ret );","title":"ecdsa_sign_restartable"},{"location":"sign/signrestartable/#restartableecdsa_sign_restartableecdsac-253","text":"","title":"restartable\u5165\u53e3\u51fd\u6570\uff1aecdsa_sign_restartable\uff08ecdsa.c 253\uff09"},{"location":"sign/signrestartable/#_1","text":"grp\uff1a\u692d\u5706\u66f2\u7ebf\u7fa4\u6307\u9488 r\u3001s\uff1a\u7528\u4e8e\u5b58\u50a8\u7b7e\u540d\u7ed3\u679c d\uff1aECDSA\u79c1\u94a5 buf\uff1a\u6b64\u5904\u8f93\u5165\u4e3a\u6d88\u606fmsg\u7684\u54c8\u5e0c\u503c blen\uff1a\u54c8\u5e0c\u503c\u957f\u5ea6 f_rng\uff1a \u968f\u673a\u6570\u751f\u6210\u51fd\u6570 p_rng\uff1a\u4f2a\u968f\u673a\u6570\u751f\u6210\u5668\u4e0a\u4e0b\u6587 restartable: \u53ef\u4ee5\u63a7\u5236\u662f\u5426\u5f00\u542frestartable\u6a21\u5f0f\uff0c\u5982\u679c\u4e3aNULL\u5219\u5173\u95ed\uff0c\u5982\u679c\u63d0\u4f9b\u5bf9\u5e94\u7684\u4e0a\u4e0b\u6587\u53ef\u4ee5\u5f00\u542f\uff0c\u652f\u6301\u4e2d\u65ad\u548c\u7ee7\u7eed\u6267\u884c\u3002","title":"\u51fd\u6570\u8f93\u5165"},{"location":"sign/signrestartable/#_2","text":"\u51fd\u6570\u8fd4\u56de\u4e00\u4e2a\u72b6\u6001\u503c\uff0c\u8868\u793a\u6210\u529f\u6216\u5931\u8d25 \u540c\u65f6\u751f\u6210\u7b7e\u540dr\u548cs","title":"\u51fd\u6570\u8f93\u51fa"},{"location":"sign/signrestartable/#_3","text":"\u70b9\u51fb\u6d41\u7a0b\u56fe\u8df3\u8f6c\u5bf9\u5e94\u51fd\u6570 graph TB Z[ecdsa_sign_restartable\u51fd\u6570] A[\u8f93\u5165] -->B(\u5b9a\u4e49\u53d8\u91cf,\u68c0\u67e5\u5408\u6cd5\u6027,\u521d\u59cb\u5316\u7ed3\u6784\u4f53) B --> C(mbedtls_ecp_gen_privkey\u751f\u6210\u968f\u673a\u6570k) subgraph \u5faa\u73af \u76f4\u5230\u751f\u6210\u7684\u7b7e\u540d\u975e\u96f6 \u6700\u591a\u5c1d\u8bd510\u6b21 subgraph \u5faa\u73af \u76f4\u5230\u751f\u6210\u7684r\u975e\u96f6 \u6700\u591a\u5c1d\u8bd510\u6b21 C --> D(mbedtls_ecp_mul_restartable) D --> E(mbedtls_mpi_mod_mpi\u5bf9r\u7684\u6a2a\u5750\u6807\u53d6\u6a21) end E --> G(restartable\u6a21\u5f0f\u5b58\u50a8\u951a\u70b9) G --> H(mbedtls_ecp_gen_privkey\u751f\u6210\u968f\u673a\u6570t) H --> I(mbedtls_mpi_mul_mpi\u8ba1\u7b97d*r) I --> J(mbedtls_mpi_add_mpi\u8ba1\u7b97a=e+d*r) J --> K(mbedtls_mpi_mul_mpi\u8ba1\u7b97t*a) K --> P(mbedtls_mpi_mul_mpi\u8ba1\u7b97k*t) P --> L(mbedtls_mpi_inv_mod\u8ba1\u7b97\u6a21N\u7684\u9006) L --> M(mbedtls_mpi_mul_mpi\u8ba1\u7b97\u672a\u53d6\u6a21\u7684\u7b7e\u540ds) M --> N(mbedtls_mpi_mod_mpi\u5bf9N\u53d6\u6a21) end N --> O(\u8f93\u51fa) click C \"../../tools/mbedtls_ecp_gen_privkey\" click E \"../../tools/mpi\" click H \"../../tools/mbedtls_ecp_gen_privkey\" click I \"../../tools/mpi\" click J \"../../tools/mpi\" click K \"../../tools/mpi\" click P \"../../tools/mpi\" click L \"../../tools/mpi\" click M \"../../tools/mpi\" click N \"../../tools/mpi\" click F \"../../tools/ECDSA_VALIDATE_RET\" click D \"../../tools/mbedtls_ecp_mul_restartable\"","title":"\u51fd\u6570\u6d41\u7a0b"},{"location":"sign/signrestartable/#_4","text":"static int ecdsa_sign_restartable ( mbedtls_ecp_group * grp , mbedtls_mpi * r , mbedtls_mpi * s , const mbedtls_mpi * d , const unsigned char * buf , size_t blen , int ( * f_rng )( void * , unsigned char * , size_t ), void * p_rng , mbedtls_ecdsa_restart_ctx * rs_ctx ) { int ret , key_tries , sign_tries ; int * p_sign_tries = & sign_tries , * p_key_tries = & key_tries ; mbedtls_ecp_point R ; mbedtls_mpi k , e , t ; mbedtls_mpi * pk = & k , * pr = r ; /* Fail cleanly on curves such as Curve25519 that can't be used for ECDSA */ if ( grp -> N . p == NULL ) return ( MBEDTLS_ERR_ECP_BAD_INPUT_DATA ); /* Make sure d is in range 1..n-1 */ if ( mbedtls_mpi_cmp_int ( d , 1 ) < 0 || mbedtls_mpi_cmp_mpi ( d , & grp -> N ) >= 0 ) return ( MBEDTLS_ERR_ECP_INVALID_KEY ); mbedtls_ecp_point_init ( & R ); mbedtls_mpi_init ( & k ); mbedtls_mpi_init ( & e ); mbedtls_mpi_init ( & t ); ECDSA_RS_ENTER ( sig ); #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> sig != NULL ) { /* redirect to our context */ p_sign_tries = & rs_ctx -> sig -> sign_tries ; p_key_tries = & rs_ctx -> sig -> key_tries ; pk = & rs_ctx -> sig -> k ; pr = & rs_ctx -> sig -> r ; /* jump to current step */ if ( rs_ctx -> sig -> state == ecdsa_sig_mul ) goto mul ; if ( rs_ctx -> sig -> state == ecdsa_sig_modn ) goto modn ; } #endif /* MBEDTLS_ECP_RESTARTABLE */ * p_sign_tries = 0 ; do { if ( * p_sign_tries ++ > 10 ) { ret = MBEDTLS_ERR_ECP_RANDOM_FAILED ; goto cleanup ; } /* * Steps 1-3: generate a suitable ephemeral keypair * and set r = xR mod n */ * p_key_tries = 0 ; do { if ( * p_key_tries ++ > 10 ) { ret = MBEDTLS_ERR_ECP_RANDOM_FAILED ; goto cleanup ; } MBEDTLS_MPI_CHK ( mbedtls_ecp_gen_privkey ( grp , pk , f_rng , p_rng ) ); #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> sig != NULL ) rs_ctx -> sig -> state = ecdsa_sig_mul ; mul : #endif MBEDTLS_MPI_CHK ( mbedtls_ecp_mul_restartable ( grp , & R , pk , & grp -> G , f_rng , p_rng , ECDSA_RS_ECP ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mod_mpi ( pr , & R . X , & grp -> N ) ); } while ( mbedtls_mpi_cmp_int ( pr , 0 ) == 0 ); #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> sig != NULL ) rs_ctx -> sig -> state = ecdsa_sig_modn ; modn : #endif /* * Accounting for everything up to the end of the loop * (step 6, but checking now avoids saving e and t) */ ECDSA_BUDGET ( MBEDTLS_ECP_OPS_INV + 4 ); /* * Step 5: derive MPI from hashed message */ MBEDTLS_MPI_CHK ( derive_mpi ( grp , & e , buf , blen ) ); /* * Generate a random value to blind inv_mod in next step, * avoiding a potential timing leak. */ MBEDTLS_MPI_CHK ( mbedtls_ecp_gen_privkey ( grp , & t , f_rng , p_rng ) ); /* * Step 6: compute s = (e + r * d) / k = t (e + rd) / (kt) mod n */ MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( s , pr , d ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_add_mpi ( & e , & e , s ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( & e , & e , & t ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( pk , pk , & t ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_inv_mod ( s , pk , & grp -> N ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( s , s , & e ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mod_mpi ( s , s , & grp -> N ) ); } while ( mbedtls_mpi_cmp_int ( s , 0 ) == 0 ); #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> sig != NULL ) mbedtls_mpi_copy ( r , pr ); #endif cleanup : mbedtls_ecp_point_free ( & R ); mbedtls_mpi_free ( & k ); mbedtls_mpi_free ( & e ); mbedtls_mpi_free ( & t ); ECDSA_RS_LEAVE ( sig ); return ( ret ); }","title":"\u51fd\u6570\u4ee3\u7801"},{"location":"sign/signrestartable/#_5","text":"\u8fdb\u884cECDSA\u7b7e\u540d \u5bf9\u7167ECDSA\u7b7e\u540d\u6d41\u7a0b\uff1a \u7b2c\u4e00\u6b65 \uff0c\u751f\u6210\u968f\u673a\u7684k \u7b2c\u4e8c\u6b65 \uff0c\u8ba1\u7b97R=k*G\uff0cG\u4e3a\u57fa\u70b9\u3002\u4ee4r=R.x\uff0c\u4e3aR\u7684\u6a2a\u5750\u6807 \u7b2c\u4e09\u6b65 \uff0c\u8ba1\u7b97z=H(msg) \u7b2c\u56db\u6b65 \uff0c\u8ba1\u7b97s=(z+r*d)/k (modN) \u6700\u540e\u5f97\u5230 \u7b7e\u540d\uff08r,s\uff09 \u4ee3\u7801\u5206\u6790\uff1a\u987a\u5e8f\u5206\u6790\u51fd\u6570\u529f\u80fd 1.\u5b9a\u4e49\u53d8\u91cf\uff0c\u5176\u4e2dR\u3001k\u3001r\u4e0e\u4e0a\u9762\u6d41\u7a0b\u4e2d\u7684\u5bf9\u5e94\u53d8\u91cf\u76f8\u5bf9\u5e94 sign_tries\u7b49\u53d8\u91cf\u5b9a\u4e49\u4e86\u5c1d\u8bd5\u6b21\u6570\u4e0a\u9650 int ret , key_tries , sign_tries ; int * p_sign_tries = & sign_tries , * p_key_tries = & key_tries ; mbedtls_ecp_point R ; mbedtls_mpi k , e , t ; mbedtls_mpi * pk = & k , * pr = r ; 2.\u68c0\u67e5\u53d8\u91cf\u662f\u5426\u5408\u6cd5\uff0c\u68c0\u67e5\u4e86\u692d\u5706\u66f2\u7ebf\u662f\u5426\u53ef\u4ee5\u7528\u4e8eECDSA\uff0c\u79c1\u94a5d\u662f\u5426\u57281\u5230n-1\u7684\u5408\u6cd5\u8303\u56f4\u5185 /* Fail cleanly on curves such as Curve25519 that can't be used for ECDSA */ if ( grp -> N . p == NULL ) return ( MBEDTLS_ERR_ECP_BAD_INPUT_DATA ); /* Make sure d is in range 1..n-1 */ if ( mbedtls_mpi_cmp_int ( d , 1 ) < 0 || mbedtls_mpi_cmp_mpi ( d , & grp -> N ) >= 0 ) return ( MBEDTLS_ERR_ECP_INVALID_KEY ); 3.\u521d\u59cb\u5316\u7ed3\u6784\u4f53 mbedtls_ecp_point_init ( & R ); mbedtls_mpi_init ( & k ); mbedtls_mpi_init ( & e ); mbedtls_mpi_init ( & t ); 4.restart\u6a21\u5f0f\u4fdd\u5b58\u4e0a\u4e0b\u6587 \u5982\u679c\u51fd\u6570\u8f93\u5165\u4e86restart\u4e0a\u4e0b\u6587\uff0c\u590d\u539f\u72b6\u6001\uff0c\u5305\u62ec\u5c1d\u8bd5\u6b21\u6570\u548c\u5df2\u7ecf\u751f\u6210\u7684k\u548cr \u4e4b\u540e\u6839\u636e\u5b58\u50a8\u7684\u6b65\u9aa4\u8df3\u8f6c\u5230\u5bf9\u5e94\u7684\u4f4d\u7f6e 5. \u4e3b\u4f53\u4ee3\u7801-\u5916\u5c42\u5faa\u73af\uff1a \u5c1d\u8bd5\u751f\u6210\u7b7e\u540d\uff0c\u5982\u679c\u7b7e\u540d\u4e3a0\u5219\u91cd\u65b0\u751f\u6210\uff0c\u6700\u591a\u670910\u6b21\u673a\u4f1a\uff0c\u8d85\u8fc7\u5219\u62a5\u9519\u8fd4\u56de \u6ce8\uff1ambedtls_mpi_cmp_int\u51fd\u6570\u5927\u4e8e\u65f6\u8fd4\u56de1\uff0c\u5c0f\u4e8e\u8fd4\u56de-1\uff0c\u76f8\u7b49\u8fd4\u56de0 * p_sign_tries = 0 ; do { if ( * p_sign_tries ++ > 10 ) { ret = MBEDTLS_ERR_ECP_RANDOM_FAILED ; goto cleanup ; } ... } while ( mbedtls_mpi_cmp_int ( s , 0 ) == 0 ); 6. \u4e3b\u4f53\u4ee3\u7801-\u5faa\u73af\u4f53\u7b2c\u4e00\u90e8\u5206\uff1a \u751f\u6210k\u548c\u5bf9\u5e94\u7684r \u7c7b\u4f3c\u5730\uff0c\u5c1d\u8bd5\u6700\u591a10\u6b21\uff0c\u76f4\u5230\u751f\u6210\u7684r\uff08\u4ee3\u7801\u4e2d\u7684pr\uff09\u975e\u96f6 \u5176\u4e2dMBEDTLS_MPI_CHK\uff08f\uff09\u51fd\u6570\u68c0\u67e5\u62ec\u53f7\u5185\u51fd\u6570f\u7684\u8fd4\u56de\u503c\uff0c\u5982\u679c\u8fd4\u56de\u503c\u975e\u96f6\uff08\u6b63\u5e38\u6267\u884c\u65f6\u8fd4\u56de0\uff09\uff0c\u5219\u62a5\u9519\u8fd4\u56de\uff0c\u4e0d\u5f71\u54cdf\u51fd\u6570\u7684\u6267\u884c \u5faa\u73af\u5185\u9996\u5148\u8c03\u7528\u4e86mbedtls_ecp_gen_privkey\u51fd\u6570\uff0c\u8fd9\u4e2a\u51fd\u6570\u7528\u6765\u751f\u6210\u6307\u5b9a\u957f\u5ea6\u7684\u968f\u673a\u6570\uff0c\u65e2\u53ef\u4ee5\u751f\u6210ECDSA\u7684\u79c1\u94a5\uff0c\u4e5f\u53ef\u4ee5\u5728\u8fd9\u91cc\u7528\u4e8e\u7b7e\u540d\u7684\u968f\u673a\u6570k\uff08\u4ee3\u7801\u4e2d\u7684pk\uff09\uff0c\u4f7f\u7528\u968f\u673a\u6570\u751f\u6210\u51fd\u6570\u548c\u4f2a\u968f\u673a\u6570\u751f\u6210\u4e0a\u4e0b\u6587\u751f\u6210\u968f\u673a\u6570\u3002 \u751f\u6210\u4e86\u968f\u673a\u7684k\uff0c\u8fd9\u91cc\u5982\u679c\u5f00\u542f\u4e86restart\u6a21\u5f0f\uff0c\u5219\u8fdb\u884c\u72b6\u6001\u5b58\u50a8rs_ctx->sig->state = ecdsa_sig_mul\uff0c\u540c\u65f6\u65ad\u70b9\u7ee7\u7eed\u6267\u884c\u65f6\u4e5f\u4ece\u8fd9\u4e00\u53e5\u4e0b\u9762\u7684mul\uff1a\u540e\u5f00\u59cb\u6267\u884c \u4e4b\u540e\u8c03\u7528mbedtls_ecp_mul_restartable\u51fd\u6570\u8ba1\u7b97R=k*G \u6700\u540e\u8c03\u7528mbedtls_mpi_mod_mpi\u51fd\u6570\u5c06R\u7684\u6a2a\u5750\u6807\u5bf9N\u53d6\u6a21 * p_key_tries = 0 ; do { if ( * p_key_tries ++ > 10 ) { ret = MBEDTLS_ERR_ECP_RANDOM_FAILED ; goto cleanup ; } MBEDTLS_MPI_CHK ( mbedtls_ecp_gen_privkey ( grp , pk , f_rng , p_rng ) ); #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> sig != NULL ) rs_ctx -> sig -> state = ecdsa_sig_mul ; mul : #endif MBEDTLS_MPI_CHK ( mbedtls_ecp_mul_restartable ( grp , & R , pk , & grp -> G , f_rng , p_rng , ECDSA_RS_ECP ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mod_mpi ( pr , & R . X , & grp -> N ) ); } while ( mbedtls_mpi_cmp_int ( pr , 0 ) == 0 ); 7. \u4e3b\u4f53\u4ee3\u7801-\u5faa\u73af\u4f53\u7b2c\u4e8c\u90e8\u5206\uff1a \u8fd9\u91cc\u5982\u679c\u5f00\u542f\u4e86restart\u6a21\u5f0f\uff0c\u5219\u8fdb\u884c\u72b6\u6001\u5b58\u50a8rs_ctx->sig->state = ecdsa_sig_modn\uff0c\u540c\u65f6\u65ad\u70b9\u7ee7\u7eed\u6267\u884c\u65f6\u4e5f\u4ece\u8fd9\u4e00\u53e5\u4e0b\u9762\u7684modn\uff1a\u540e\u5f00\u59cb\u6267\u884c #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> sig != NULL ) rs_ctx -> sig -> state = ecdsa_sig_modn ; modn : 8. \u4e3b\u4f53\u4ee3\u7801-\u5faa\u73af\u4f53\u7b2c\u4e09\u90e8\u5206 \uff1a\u8ba1\u7b97\u53e6\u4e00\u90e8\u5206\u7b7e\u540ds ECDSA_BUDGET\u4e3a\u4e00\u4e2a\u7a7a\u7684\u5b8f\uff0c\u6ca1\u6709\u4f5c\u7528 #define ECDSA_BUDGET( ops ) /* no-op; for compatibility */ \u4e4b\u540e\u7684derive_mpi\u4ece\u9884\u5148\u751f\u6210\u7684\u54c8\u5e0cbuf\u751f\u6210\u4e00\u4e2a\u5927\u6574\u6570 mbedtls_ecp_gen_privkey\u4e0e\u4e4b\u524d\u76f8\u540c\uff0c\u751f\u6210\u4e00\u4e2a\u968f\u673a\u7684t t\u7684\u4f5c\u7528\uff1a\u4e3a\u4e86\u907f\u514d\u4f7f\u7528\u76f8\u540c\u7684\u968f\u673a\u6570\u800c\u5bfc\u81f4\u79c1\u94a5\u6cc4\u9732\uff0c\u9700\u8981\u4f7f\u7528\u4e00\u4e2a\u79f0\u4e3a\u201c\u7b7e\u540d\u76f2\u5316\u56e0\u5b50\u201d\uff08blinding factor\uff09\u7684\u968f\u673a\u6570\u6765\u76f2\u5316\u7b7e\u540d\u8fc7\u7a0b\u3002\u5728\u4e0a\u8ff0\u4ee3\u7801\u4e2d\uff0ct \u5c31\u662f\u4e00\u4e2a\u7b7e\u540d\u76f2\u5316\u56e0\u5b50\uff0c\u5b83\u662f\u901a\u8fc7\u8c03\u7528 mbedtls_ecp_gen_privkey \u51fd\u6570\u751f\u6210\u7684\u4e00\u4e2a\u968f\u673a\u6570\u3002\u751f\u6210\u968f\u673a\u6570\u7684\u8fc7\u7a0b\u662f\u4e3a\u4e86\u9632\u6b62\u4f7f\u7528\u76f8\u540c\u7684\u968f\u673a\u6570\u8fdb\u884c\u7b7e\u540d\u800c\u5bfc\u81f4\u79c1\u94a5\u6cc4\u9732\uff0c\u56e0\u4e3a\u6b64\u65f6\u653b\u51fb\u8005\u53ef\u80fd\u4f1a\u901a\u8fc7\u591a\u6b21\u89c2\u5bdf\u7b7e\u540d\u7ed3\u679c\u6765\u8ba1\u7b97\u51fa\u79c1\u94a5\u3002 \u4e4b\u540e\u7684\u4e00\u8fde\u4e32\u8ba1\u7b97\u4e3a\u8ba1\u7b97t (e + rd) / (kt) mod n \u7684\u8fc7\u7a0b ECDSA_BUDGET ( MBEDTLS_ECP_OPS_INV + 4 ); /* * Step 5: derive MPI from hashed message */ MBEDTLS_MPI_CHK ( derive_mpi ( grp , & e , buf , blen ) ); /* * Generate a random value to blind inv_mod in next step, * avoiding a potential timing leak. */ MBEDTLS_MPI_CHK ( mbedtls_ecp_gen_privkey ( grp , & t , f_rng , p_rng ) ); /* * Step 6: compute s = (e + r * d) / k = t (e + rd) / (kt) mod n */ MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( s , pr , d ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_add_mpi ( & e , & e , s ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( & e , & e , & t ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( pk , pk , & t ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_inv_mod ( s , pk , & grp -> N ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( s , s , & e ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mod_mpi ( s , s , & grp -> N ) ); 9.\u51fd\u6570\u7ed3\u5c3e\u90e8\u5206\uff0c\u5b58\u50a8\u72b6\u6001\u3001\u91ca\u653e\u7a7a\u95f4 #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> sig != NULL ) mbedtls_mpi_copy ( r , pr ); #endif cleanup : mbedtls_ecp_point_free ( & R ); mbedtls_mpi_free ( & k ); mbedtls_mpi_free ( & e ); mbedtls_mpi_free ( & t ); ECDSA_RS_LEAVE ( sig ); return ( ret );","title":"\u51fd\u6570\u8bf4\u660e"},{"location":"tools/ECDSA_VALIDATE_RET/","text":"ECDSA_VALIDATE_RET \u51fd\u6570\u4f4d\u7f6eecdsa.c \u4ee3\u7801\uff1a #define ECDSA_VALIDATE_RET( cond ) \\ MBEDTLS_INTERNAL_VALIDATE_RET( cond, MBEDTLS_ERR_ECP_BAD_INPUT_DATA ) \u5176\u4e2d MBEDTLS_INTERNAL_VALIDATE_RET \u7684\u5b9a\u4e49\u4e3a #define MBEDTLS_INTERNAL_VALIDATE_RET( cond, ret ) do { } while( 0 ) \u6b64\u5904\u51fd\u6570\u4e3a\u7a7a","title":"ECDSA_VALIDATE_RET"},{"location":"tools/ECDSA_VALIDATE_RET/#ecdsa_validate_ret","text":"\u51fd\u6570\u4f4d\u7f6eecdsa.c \u4ee3\u7801\uff1a #define ECDSA_VALIDATE_RET( cond ) \\ MBEDTLS_INTERNAL_VALIDATE_RET( cond, MBEDTLS_ERR_ECP_BAD_INPUT_DATA ) \u5176\u4e2d MBEDTLS_INTERNAL_VALIDATE_RET \u7684\u5b9a\u4e49\u4e3a #define MBEDTLS_INTERNAL_VALIDATE_RET( cond, ret ) do { } while( 0 ) \u6b64\u5904\u51fd\u6570\u4e3a\u7a7a","title":"ECDSA_VALIDATE_RET"},{"location":"tools/ecp_mul_comb_core/","text":"ecp_mul_comb_core\uff08ecp.c 1781\uff09 \u51fd\u6570\u4ee3\u7801 static int ecp_mul_comb_core ( const mbedtls_ecp_group * grp , mbedtls_ecp_point * R , const mbedtls_ecp_point T [], unsigned char T_size , const unsigned char x [], size_t d , int ( * f_rng )( void * , unsigned char * , size_t ), void * p_rng , mbedtls_ecp_restart_ctx * rs_ctx ) { int ret ; mbedtls_ecp_point Txi ; size_t i ; mbedtls_ecp_point_init ( & Txi ); #if !defined(MBEDTLS_ECP_RESTARTABLE) ( void ) rs_ctx ; #endif #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> rsm != NULL && rs_ctx -> rsm -> state != ecp_rsm_comb_core ) { rs_ctx -> rsm -> i = 0 ; rs_ctx -> rsm -> state = ecp_rsm_comb_core ; } /* new 'if' instead of nested for the sake of the 'else' branch */ if ( rs_ctx != NULL && rs_ctx -> rsm != NULL && rs_ctx -> rsm -> i != 0 ) { /* restore current index (R already pointing to rs_ctx->rsm->R) */ i = rs_ctx -> rsm -> i ; } else #endif { /* Start with a non-zero point and randomize its coordinates */ i = d ; MBEDTLS_MPI_CHK ( ecp_select_comb ( grp , R , T , T_size , x [ i ] ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_lset ( & R -> Z , 1 ) ); if ( f_rng != 0 ) MBEDTLS_MPI_CHK ( ecp_randomize_jac ( grp , R , f_rng , p_rng ) ); } while ( i != 0 ) { MBEDTLS_ECP_BUDGET ( MBEDTLS_ECP_OPS_DBL + MBEDTLS_ECP_OPS_ADD ); -- i ; MBEDTLS_MPI_CHK ( ecp_double_jac ( grp , R , R ) ); MBEDTLS_MPI_CHK ( ecp_select_comb ( grp , & Txi , T , T_size , x [ i ] ) ); MBEDTLS_MPI_CHK ( ecp_add_mixed ( grp , R , R , & Txi ) ); } cleanup : mbedtls_ecp_point_free ( & Txi ); #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> rsm != NULL && ret == MBEDTLS_ERR_ECP_IN_PROGRESS ) { rs_ctx -> rsm -> i = i ; /* no need to save R, already pointing to rs_ctx->rsm->R */ } #endif return ( ret ); } \u51fd\u6570\u8bf4\u660e \u7236\u51fd\u6570ecp_mul_comb_after_precomp \u4f7f\u7528\u7ec4\u5408\u65b9\u6cd5\u8ba1\u7b97\u692d\u5706\u66f2\u7ebf\u4e0a\u7684\u4e58\u6cd5\u8fd0\u7b97 \u5f53\u8ba1\u6570\u5668 i \u4e0d\u4e3a 0 \u65f6\uff0c\u8fdb\u5165\u5faa\u73af\u3002 \u4f7f\u7528 ecp_double_jac \u51fd\u6570\u5bf9\u70b9 R \u8fdb\u884c\u500d\u70b9\u8fd0\u7b97\u3002 \u4f7f\u7528 ecp_select_comb \u51fd\u6570\u6839\u636e\u4e58\u6cd5\u56e0\u5b50 x[i] \u9009\u62e9\u5bf9\u5e94\u7684\u8f93\u5165\u70b9 T[i] \u3002 \u4f7f\u7528 ecp_add_mixed \u51fd\u6570\u5c06\u500d\u70b9\u7ed3\u679c R \u4e0e\u9009\u62e9\u7684\u8f93\u5165\u70b9 Txi \u76f8\u52a0\uff0c\u5f97\u5230\u65b0\u7684\u500d\u70b9\u7ed3\u679c\u3002 \u8ba1\u6570\u5668 i \u81ea\u51cf\uff0c\u8fdb\u5165\u4e0b\u4e00\u6b21\u5faa\u73af\u3002","title":"ecp_mul_comb_core"},{"location":"tools/ecp_mul_comb_core/#ecp_mul_comb_coreecpc-1781","text":"","title":"ecp_mul_comb_core\uff08ecp.c 1781\uff09"},{"location":"tools/ecp_mul_comb_core/#_1","text":"static int ecp_mul_comb_core ( const mbedtls_ecp_group * grp , mbedtls_ecp_point * R , const mbedtls_ecp_point T [], unsigned char T_size , const unsigned char x [], size_t d , int ( * f_rng )( void * , unsigned char * , size_t ), void * p_rng , mbedtls_ecp_restart_ctx * rs_ctx ) { int ret ; mbedtls_ecp_point Txi ; size_t i ; mbedtls_ecp_point_init ( & Txi ); #if !defined(MBEDTLS_ECP_RESTARTABLE) ( void ) rs_ctx ; #endif #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> rsm != NULL && rs_ctx -> rsm -> state != ecp_rsm_comb_core ) { rs_ctx -> rsm -> i = 0 ; rs_ctx -> rsm -> state = ecp_rsm_comb_core ; } /* new 'if' instead of nested for the sake of the 'else' branch */ if ( rs_ctx != NULL && rs_ctx -> rsm != NULL && rs_ctx -> rsm -> i != 0 ) { /* restore current index (R already pointing to rs_ctx->rsm->R) */ i = rs_ctx -> rsm -> i ; } else #endif { /* Start with a non-zero point and randomize its coordinates */ i = d ; MBEDTLS_MPI_CHK ( ecp_select_comb ( grp , R , T , T_size , x [ i ] ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_lset ( & R -> Z , 1 ) ); if ( f_rng != 0 ) MBEDTLS_MPI_CHK ( ecp_randomize_jac ( grp , R , f_rng , p_rng ) ); } while ( i != 0 ) { MBEDTLS_ECP_BUDGET ( MBEDTLS_ECP_OPS_DBL + MBEDTLS_ECP_OPS_ADD ); -- i ; MBEDTLS_MPI_CHK ( ecp_double_jac ( grp , R , R ) ); MBEDTLS_MPI_CHK ( ecp_select_comb ( grp , & Txi , T , T_size , x [ i ] ) ); MBEDTLS_MPI_CHK ( ecp_add_mixed ( grp , R , R , & Txi ) ); } cleanup : mbedtls_ecp_point_free ( & Txi ); #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> rsm != NULL && ret == MBEDTLS_ERR_ECP_IN_PROGRESS ) { rs_ctx -> rsm -> i = i ; /* no need to save R, already pointing to rs_ctx->rsm->R */ } #endif return ( ret ); }","title":"\u51fd\u6570\u4ee3\u7801"},{"location":"tools/ecp_mul_comb_core/#_2","text":"\u7236\u51fd\u6570ecp_mul_comb_after_precomp \u4f7f\u7528\u7ec4\u5408\u65b9\u6cd5\u8ba1\u7b97\u692d\u5706\u66f2\u7ebf\u4e0a\u7684\u4e58\u6cd5\u8fd0\u7b97 \u5f53\u8ba1\u6570\u5668 i \u4e0d\u4e3a 0 \u65f6\uff0c\u8fdb\u5165\u5faa\u73af\u3002 \u4f7f\u7528 ecp_double_jac \u51fd\u6570\u5bf9\u70b9 R \u8fdb\u884c\u500d\u70b9\u8fd0\u7b97\u3002 \u4f7f\u7528 ecp_select_comb \u51fd\u6570\u6839\u636e\u4e58\u6cd5\u56e0\u5b50 x[i] \u9009\u62e9\u5bf9\u5e94\u7684\u8f93\u5165\u70b9 T[i] \u3002 \u4f7f\u7528 ecp_add_mixed \u51fd\u6570\u5c06\u500d\u70b9\u7ed3\u679c R \u4e0e\u9009\u62e9\u7684\u8f93\u5165\u70b9 Txi \u76f8\u52a0\uff0c\u5f97\u5230\u65b0\u7684\u500d\u70b9\u7ed3\u679c\u3002 \u8ba1\u6570\u5668 i \u81ea\u51cf\uff0c\u8fdb\u5165\u4e0b\u4e00\u6b21\u5faa\u73af\u3002","title":"\u51fd\u6570\u8bf4\u660e"},{"location":"tools/ecp_safe_invert_jac/","text":"ecp_safe_invert_jac (ecp.c 1226) \u51fd\u6570\u6d41\u7a0b graph TB Z[ecp_safe_invert_jac\u51fd\u6570] A[\u8f93\u5165] -->B(\u521d\u59cb\u5316) B --> C(\u8ba1\u7b97P - Q.Y) C --> D[mbedtls_mpi_safe_cond_assign\u51fd\u6570] subgraph a D --> E(\u65f6\u95f4\u6052\u5b9a\u7684\u6761\u4ef6\u8d4b\u503c) end E --> R[\u8f93\u51fa] \u51fd\u6570\u4ee3\u7801 static int ecp_safe_invert_jac ( const mbedtls_ecp_group * grp , mbedtls_ecp_point * Q , unsigned char inv ) { int ret ; unsigned char nonzero ; mbedtls_mpi mQY ; mbedtls_mpi_init ( & mQY ); /* Use the fact that -Q.Y mod P = P - Q.Y unless Q.Y == 0 */ MBEDTLS_MPI_CHK ( mbedtls_mpi_sub_mpi ( & mQY , & grp -> P , & Q -> Y ) ); nonzero = mbedtls_mpi_cmp_int ( & Q -> Y , 0 ) != 0 ; MBEDTLS_MPI_CHK ( mbedtls_mpi_safe_cond_assign ( & Q -> Y , & mQY , inv & nonzero ) ); cleanup : mbedtls_mpi_free ( & mQY ); return ( ret ); } \u51fd\u6570\u8bf4\u660e \u9996\u5148\uff0c\u901a\u8fc7\u8c03\u7528 mbedtls_mpi_init() \u51fd\u6570\u5bf9 mQY \u8fdb\u884c\u521d\u59cb\u5316\u3002 \u63a5\u4e0b\u6765\uff0c\u8ba1\u7b97 -Q.Y mod P \uff0c\u5373 P - Q.Y \uff0c\u5e76\u5c06\u7ed3\u679c\u5b58\u50a8\u5728 mQY \u4e2d\u3002\u8fd9\u4e00\u6b65\u5229\u7528\u4e86\u692d\u5706\u66f2\u7ebf\u7684\u6027\u8d28\uff0c\u5373 -Q.Y mod P \u7b49\u4e8e P - Q.Y \u3002 \u7136\u540e\uff0c\u5224\u65ad\u70b9 Q \u7684 Y \u5750\u6807\u662f\u5426\u4e3a\u975e\u96f6\u503c\uff0c\u5c06\u5224\u65ad\u7ed3\u679c\u5b58\u50a8\u5728 nonzero \u4e2d\u3002 \u4f7f\u7528 mbedtls_mpi_safe_cond_assign() \u51fd\u6570\u6839\u636e inv \u548c nonzero \u7684\u503c\u6765\u8fdb\u884c\u6761\u4ef6\u8d4b\u503c\u64cd\u4f5c\uff0c\u5373\u5982\u679c inv \u4e3a\u771f\u4e14 nonzero \u4e3a\u771f\uff0c\u5219\u5c06 mQY \u7684\u503c\u8d4b\u7ed9 Q->Y \uff0c\u5426\u5219\u4e0d\u8fdb\u884c\u8d4b\u503c\u64cd\u4f5c\u3002 \u6700\u540e\uff0c\u901a\u8fc7\u8c03\u7528 mbedtls_mpi_free() \u51fd\u6570\u91ca\u653e mQY \u7684\u5185\u5b58\u7a7a\u95f4\u3002 mbedtls_mpi_safe_cond_assign\uff08bignum.c 249\uff09\u51fd\u6570\u4ee3\u7801 int mbedtls_mpi_safe_cond_assign ( mbedtls_mpi * X , const mbedtls_mpi * Y , unsigned char assign ) { int ret = 0 ; size_t i ; MPI_VALIDATE_RET ( X != NULL ); MPI_VALIDATE_RET ( Y != NULL ); /* make sure assign is 0 or 1 in a time-constant manner */ assign = ( assign | ( unsigned char ) - assign ) >> 7 ; MBEDTLS_MPI_CHK ( mbedtls_mpi_grow ( X , Y -> n ) ); X -> s = X -> s * ( 1 - assign ) + Y -> s * assign ; for ( i = 0 ; i < Y -> n ; i ++ ) X -> p [ i ] = X -> p [ i ] * ( 1 - assign ) + Y -> p [ i ] * assign ; for ( ; i < X -> n ; i ++ ) X -> p [ i ] *= ( 1 - assign ); cleanup : return ( ret ); } mbedtls_mpi_safe_cond_assign\u51fd\u6570\u8bf4\u660e \u6761\u4ef6\u8d4b\u503cX=Y\uff0c\u4e0d\u6cc4\u9732\u4fe1\u606f\u3002 assign = (assign | (unsigned char)-assign) >> 7; \u8fd9\u6bb5\u4ee3\u7801\u7684\u76ee\u7684\u662f\u786e\u4fdd assign \u7684\u503c\u5728\u65f6\u95f4\u4e0a\u662f\u6052\u5b9a\u7684 \uff0c\u5e76\u5c06\u5176\u9650\u5236\u4e3a0\u62161\u3002\u5b83\u4f7f\u7528\u4f4d\u8fd0\u7b97\u5c06 assign \u4e0e\u5176\u8d1f\u503c\u6309\u4f4d\u6216\u8fd0\u7b97\uff0c\u7136\u540e\u53f3\u79fb7\u4f4d\uff0c\u4ece\u800c\u5c06 assign \u7684\u6700\u9ad8\u6709\u6548\u4f4d\u79fb\u4f4d\u5230\u6700\u4f4e\u6709\u6548\u4f4d\uff0c\u5f97\u52300\u62161\u3002 \u7136\u540e\uff0c\u901a\u8fc7\u8c03\u7528 mbedtls_mpi_grow \u51fd\u6570\uff0c\u4f7f X \u7684\u5927\u5c0f\u589e\u957f\u5230\u4e0e Y->n \u76f8\u540c\u7684\u957f\u5ea6\uff1a MBEDTLS_MPI_CHK(mbedtls_mpi_grow( X, Y->n )); \u63a5\u4e0b\u6765\uff0c\u5faa\u73af\u5bf9 X->p[i] \u8fdb\u884c\u6761\u4ef6\u8d4b\u503c\uff1a for( i = 0; i < Y->n; i++ ) X->p[i] = X->p[i] * ( 1 - assign ) + Y->p[i] * assign; \u8fd9\u6bb5\u4ee3\u7801\u6839\u636e assign \u7684\u503c\uff080\u62161\uff09\uff0c\u5bf9 X->p[i] \u8fdb\u884c\u6761\u4ef6\u8d4b\u503c\u3002\u5982\u679c assign \u4e3a0\uff0c\u5219\u5c06 X->p[i] \u4e58\u4ee5(1 - assign)\uff0c\u53730\uff0c\u7136\u540e\u52a0\u4e0a Y->p[i] \u4e58\u4ee5assign\uff0c\u5373\u4e3a0\uff1b\u5982\u679c assign \u4e3a1\uff0c\u5219\u5c06 X->p[i] \u4e58\u4ee5(1 - assign)\uff0c\u5373\u4e3a0\uff0c\u7136\u540e\u52a0\u4e0a Y->p[i] \u4e58\u4ee5assign\uff0c\u5373\u4e3a Y->p[i] \u3002 \u6700\u540e\uff0c\u5bf9\u4e8e i \u4ece Y->n \u5230 X->n \u7684\u8303\u56f4\uff0c\u5c06 X->p[i] \u4e58\u4ee5(1 - assign)\uff1a for( ; i < X->n; i++ ) X->p[i] *= ( 1 - assign );","title":"ecp_safe_invert_jac"},{"location":"tools/ecp_safe_invert_jac/#ecp_safe_invert_jac-ecpc-1226","text":"","title":"ecp_safe_invert_jac (ecp.c 1226)"},{"location":"tools/ecp_safe_invert_jac/#_1","text":"graph TB Z[ecp_safe_invert_jac\u51fd\u6570] A[\u8f93\u5165] -->B(\u521d\u59cb\u5316) B --> C(\u8ba1\u7b97P - Q.Y) C --> D[mbedtls_mpi_safe_cond_assign\u51fd\u6570] subgraph a D --> E(\u65f6\u95f4\u6052\u5b9a\u7684\u6761\u4ef6\u8d4b\u503c) end E --> R[\u8f93\u51fa]","title":"\u51fd\u6570\u6d41\u7a0b"},{"location":"tools/ecp_safe_invert_jac/#_2","text":"static int ecp_safe_invert_jac ( const mbedtls_ecp_group * grp , mbedtls_ecp_point * Q , unsigned char inv ) { int ret ; unsigned char nonzero ; mbedtls_mpi mQY ; mbedtls_mpi_init ( & mQY ); /* Use the fact that -Q.Y mod P = P - Q.Y unless Q.Y == 0 */ MBEDTLS_MPI_CHK ( mbedtls_mpi_sub_mpi ( & mQY , & grp -> P , & Q -> Y ) ); nonzero = mbedtls_mpi_cmp_int ( & Q -> Y , 0 ) != 0 ; MBEDTLS_MPI_CHK ( mbedtls_mpi_safe_cond_assign ( & Q -> Y , & mQY , inv & nonzero ) ); cleanup : mbedtls_mpi_free ( & mQY ); return ( ret ); }","title":"\u51fd\u6570\u4ee3\u7801"},{"location":"tools/ecp_safe_invert_jac/#_3","text":"\u9996\u5148\uff0c\u901a\u8fc7\u8c03\u7528 mbedtls_mpi_init() \u51fd\u6570\u5bf9 mQY \u8fdb\u884c\u521d\u59cb\u5316\u3002 \u63a5\u4e0b\u6765\uff0c\u8ba1\u7b97 -Q.Y mod P \uff0c\u5373 P - Q.Y \uff0c\u5e76\u5c06\u7ed3\u679c\u5b58\u50a8\u5728 mQY \u4e2d\u3002\u8fd9\u4e00\u6b65\u5229\u7528\u4e86\u692d\u5706\u66f2\u7ebf\u7684\u6027\u8d28\uff0c\u5373 -Q.Y mod P \u7b49\u4e8e P - Q.Y \u3002 \u7136\u540e\uff0c\u5224\u65ad\u70b9 Q \u7684 Y \u5750\u6807\u662f\u5426\u4e3a\u975e\u96f6\u503c\uff0c\u5c06\u5224\u65ad\u7ed3\u679c\u5b58\u50a8\u5728 nonzero \u4e2d\u3002 \u4f7f\u7528 mbedtls_mpi_safe_cond_assign() \u51fd\u6570\u6839\u636e inv \u548c nonzero \u7684\u503c\u6765\u8fdb\u884c\u6761\u4ef6\u8d4b\u503c\u64cd\u4f5c\uff0c\u5373\u5982\u679c inv \u4e3a\u771f\u4e14 nonzero \u4e3a\u771f\uff0c\u5219\u5c06 mQY \u7684\u503c\u8d4b\u7ed9 Q->Y \uff0c\u5426\u5219\u4e0d\u8fdb\u884c\u8d4b\u503c\u64cd\u4f5c\u3002 \u6700\u540e\uff0c\u901a\u8fc7\u8c03\u7528 mbedtls_mpi_free() \u51fd\u6570\u91ca\u653e mQY \u7684\u5185\u5b58\u7a7a\u95f4\u3002","title":"\u51fd\u6570\u8bf4\u660e"},{"location":"tools/ecp_safe_invert_jac/#mbedtls_mpi_safe_cond_assignbignumc-249","text":"int mbedtls_mpi_safe_cond_assign ( mbedtls_mpi * X , const mbedtls_mpi * Y , unsigned char assign ) { int ret = 0 ; size_t i ; MPI_VALIDATE_RET ( X != NULL ); MPI_VALIDATE_RET ( Y != NULL ); /* make sure assign is 0 or 1 in a time-constant manner */ assign = ( assign | ( unsigned char ) - assign ) >> 7 ; MBEDTLS_MPI_CHK ( mbedtls_mpi_grow ( X , Y -> n ) ); X -> s = X -> s * ( 1 - assign ) + Y -> s * assign ; for ( i = 0 ; i < Y -> n ; i ++ ) X -> p [ i ] = X -> p [ i ] * ( 1 - assign ) + Y -> p [ i ] * assign ; for ( ; i < X -> n ; i ++ ) X -> p [ i ] *= ( 1 - assign ); cleanup : return ( ret ); }","title":"mbedtls_mpi_safe_cond_assign\uff08bignum.c 249\uff09\u51fd\u6570\u4ee3\u7801"},{"location":"tools/ecp_safe_invert_jac/#mbedtls_mpi_safe_cond_assign","text":"\u6761\u4ef6\u8d4b\u503cX=Y\uff0c\u4e0d\u6cc4\u9732\u4fe1\u606f\u3002 assign = (assign | (unsigned char)-assign) >> 7; \u8fd9\u6bb5\u4ee3\u7801\u7684\u76ee\u7684\u662f\u786e\u4fdd assign \u7684\u503c\u5728\u65f6\u95f4\u4e0a\u662f\u6052\u5b9a\u7684 \uff0c\u5e76\u5c06\u5176\u9650\u5236\u4e3a0\u62161\u3002\u5b83\u4f7f\u7528\u4f4d\u8fd0\u7b97\u5c06 assign \u4e0e\u5176\u8d1f\u503c\u6309\u4f4d\u6216\u8fd0\u7b97\uff0c\u7136\u540e\u53f3\u79fb7\u4f4d\uff0c\u4ece\u800c\u5c06 assign \u7684\u6700\u9ad8\u6709\u6548\u4f4d\u79fb\u4f4d\u5230\u6700\u4f4e\u6709\u6548\u4f4d\uff0c\u5f97\u52300\u62161\u3002 \u7136\u540e\uff0c\u901a\u8fc7\u8c03\u7528 mbedtls_mpi_grow \u51fd\u6570\uff0c\u4f7f X \u7684\u5927\u5c0f\u589e\u957f\u5230\u4e0e Y->n \u76f8\u540c\u7684\u957f\u5ea6\uff1a MBEDTLS_MPI_CHK(mbedtls_mpi_grow( X, Y->n )); \u63a5\u4e0b\u6765\uff0c\u5faa\u73af\u5bf9 X->p[i] \u8fdb\u884c\u6761\u4ef6\u8d4b\u503c\uff1a for( i = 0; i < Y->n; i++ ) X->p[i] = X->p[i] * ( 1 - assign ) + Y->p[i] * assign; \u8fd9\u6bb5\u4ee3\u7801\u6839\u636e assign \u7684\u503c\uff080\u62161\uff09\uff0c\u5bf9 X->p[i] \u8fdb\u884c\u6761\u4ef6\u8d4b\u503c\u3002\u5982\u679c assign \u4e3a0\uff0c\u5219\u5c06 X->p[i] \u4e58\u4ee5(1 - assign)\uff0c\u53730\uff0c\u7136\u540e\u52a0\u4e0a Y->p[i] \u4e58\u4ee5assign\uff0c\u5373\u4e3a0\uff1b\u5982\u679c assign \u4e3a1\uff0c\u5219\u5c06 X->p[i] \u4e58\u4ee5(1 - assign)\uff0c\u5373\u4e3a0\uff0c\u7136\u540e\u52a0\u4e0a Y->p[i] \u4e58\u4ee5assign\uff0c\u5373\u4e3a Y->p[i] \u3002 \u6700\u540e\uff0c\u5bf9\u4e8e i \u4ece Y->n \u5230 X->n \u7684\u8303\u56f4\uff0c\u5c06 X->p[i] \u4e58\u4ee5(1 - assign)\uff1a for( ; i < X->n; i++ ) X->p[i] *= ( 1 - assign );","title":"mbedtls_mpi_safe_cond_assign\u51fd\u6570\u8bf4\u660e"},{"location":"tools/mbedtls_ecp_gen_privkey/","text":"mbedtls_ecp_gen_privkey(ecp.c 2680) \u51fd\u6570\u6d41\u7a0b \u70b9\u51fb\u6d41\u7a0b\u56fe\u8df3\u8f6c\u5bf9\u5e94\u51fd\u6570 graph TB Z[mbedtls_ecp_gen_privkey\u51fd\u6570] A[\u8f93\u5165] -->B(\u5b9a\u4e49\u53d8\u91cf,\u68c0\u67e5\u5408\u6cd5\u6027) B --> |ECP_MONTGOMERY|C(mbedtls_mpi_fill_random\u751f\u6210\u968f\u673a\u6570) B --> |ECP_SHORTWEIERSTRASS|D(mbedtls_mpi_fill_random\u751f\u6210\u968f\u673a\u6570) C --> E(\u6700\u4f4e\u76842\u52303\u4f4d\u6e05\u96f6) D --> G(\u5982\u679c\u5931\u8d25\u91cd\u65b0\u751f\u6210) G --> H[\u8f93\u51fa] E --> H click C \"../../tools/mbedtls_mpi_fill_random\" click D \"../../tools/mbedtls_mpi_fill_random\" \u51fd\u6570\u4ee3\u7801 mbedtls_ecp_gen_privkey int mbedtls_ecp_gen_privkey ( const mbedtls_ecp_group * grp , mbedtls_mpi * d , int ( * f_rng )( void * , unsigned char * , size_t ), void * p_rng ) { int ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA ; size_t n_size ; ECP_VALIDATE_RET ( grp != NULL ); ECP_VALIDATE_RET ( d != NULL ); ECP_VALIDATE_RET ( f_rng != NULL ); n_size = ( grp -> nbits + 7 ) / 8 ; #if defined(ECP_MONTGOMERY) if ( ecp_get_type ( grp ) == ECP_TYPE_MONTGOMERY ) { /* [M225] page 5 */ size_t b ; do { MBEDTLS_MPI_CHK ( mbedtls_mpi_fill_random ( d , n_size , f_rng , p_rng ) ); } while ( mbedtls_mpi_bitlen ( d ) == 0 ); /* Make sure the most significant bit is nbits */ b = mbedtls_mpi_bitlen ( d ) - 1 ; /* mbedtls_mpi_bitlen is one-based */ if ( b > grp -> nbits ) MBEDTLS_MPI_CHK ( mbedtls_mpi_shift_r ( d , b - grp -> nbits ) ); else MBEDTLS_MPI_CHK ( mbedtls_mpi_set_bit ( d , grp -> nbits , 1 ) ); /* Make sure the last two bits are unset for Curve448, three bits for Curve25519 */ MBEDTLS_MPI_CHK ( mbedtls_mpi_set_bit ( d , 0 , 0 ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_set_bit ( d , 1 , 0 ) ); if ( grp -> nbits == 254 ) { MBEDTLS_MPI_CHK ( mbedtls_mpi_set_bit ( d , 2 , 0 ) ); } } #endif /* ECP_MONTGOMERY */ #if defined(ECP_SHORTWEIERSTRASS) if ( ecp_get_type ( grp ) == ECP_TYPE_SHORT_WEIERSTRASS ) { /* SEC1 3.2.1: Generate d such that 1 <= n < N */ int count = 0 ; /* * Match the procedure given in RFC 6979 (deterministic ECDSA): * - use the same byte ordering; * - keep the leftmost nbits bits of the generated octet string; * - try until result is in the desired range. * This also avoids any biais, which is especially important for ECDSA. */ do { MBEDTLS_MPI_CHK ( mbedtls_mpi_fill_random ( d , n_size , f_rng , p_rng ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_shift_r ( d , 8 * n_size - grp -> nbits ) ); /* * Each try has at worst a probability 1/2 of failing (the msb has * a probability 1/2 of being 0, and then the result will be < N), * so after 30 tries failure probability is a most 2**(-30). * * For most curves, 1 try is enough with overwhelming probability, * since N starts with a lot of 1s in binary, but some curves * such as secp224k1 are actually very close to the worst case. */ if ( ++ count > 30 ) return ( MBEDTLS_ERR_ECP_RANDOM_FAILED ); } while ( mbedtls_mpi_cmp_int ( d , 1 ) < 0 || mbedtls_mpi_cmp_mpi ( d , & grp -> N ) >= 0 ); } #endif /* ECP_SHORTWEIERSTRASS */ cleanup : return ( ret ); } \u51fd\u6570\u8bf4\u660e \u51fd\u6570\u6839\u636e\u4e0d\u540c\u7684\u66f2\u7ebf\u7c7b\u578b\u751f\u6210\u4e0d\u540c\u7684\u6ee1\u8db3\u8981\u6c42\u7684\u968f\u673a\u6570 \u66f2\u7ebf\u7c7b\u578b\u5305\u62ec\uff1a There are several different ways to express elliptic curves over F_p: The short Weierstrass equation y^2 = x^3 + ax + b, where 4a^3+27b^2 is nonzero in F_p, is an elliptic curve over F_p. Every elliptic curve over F_p can be converted to a short Weierstrass equation if p is larger than 3. The Montgomery equation By^2 = x^3 + Ax^2 + x, where B(A^2-4) is nonzero in F_p, is an elliptic curve over F_p. Substituting x = Bu-A/3 and y = Bv produces the short Weierstrass equation v^2 = u^3 + au + b where a = (3-A^2)/(3B^2) and b = (2A^3-9A)/(27B^3). Montgomery curves were introduced by 1987 Montgomery . The Edwards equation x^2 + y^2 = 1 + dx^2y^2, where d(1-d) is nonzero in F_p, is an elliptic curve over F_p. Substituting x = u/v and y = (u-1)/(u+1) produces the Montgomery equation Bv^2 = u^3 + Au^2 + u where A = 2(1+d)/(1-d) and B = 4/(1-d). Edwards curves were introduced by 2007 Edwards in the case that d is a 4th power. SafeCurves requires Edwards curves to be complete , i.e., for d to not be a square; complete Edwards curves were introduced by 2007 Bernstein\u2013Lange . \u5176\u4e2dmbedtls\u652f\u6301\u7684\u662f Montgomery equation \u548c short Weierstrass equation \u51fd\u6570\u7684\u6838\u5fc3\u4e3ambedtls_mpi_fill_random\u51fd\u6570 \u51fd\u6570\u5148\u8c03\u7528mbedtls_mpi_fill_random\u51fd\u6570\u751f\u6210\u968f\u673a\u6570\uff0c\u518d\u6839\u636e\u66f2\u7ebf\u7c7b\u578b\u8c03\u6574 \u4f8b\u5982\u5982\u679c\u692d\u5706\u66f2\u7ebf\u7c7b\u578b\u4e3a Montgomery\uff0c\u5219\u5c06\u6700\u4f4e\u76842\u52303\u4f4d\u6e05\u96f6","title":"mbedtls_ecp_gen_privkey"},{"location":"tools/mbedtls_ecp_gen_privkey/#mbedtls_ecp_gen_privkeyecpc-2680","text":"","title":"mbedtls_ecp_gen_privkey(ecp.c 2680)"},{"location":"tools/mbedtls_ecp_gen_privkey/#_1","text":"\u70b9\u51fb\u6d41\u7a0b\u56fe\u8df3\u8f6c\u5bf9\u5e94\u51fd\u6570 graph TB Z[mbedtls_ecp_gen_privkey\u51fd\u6570] A[\u8f93\u5165] -->B(\u5b9a\u4e49\u53d8\u91cf,\u68c0\u67e5\u5408\u6cd5\u6027) B --> |ECP_MONTGOMERY|C(mbedtls_mpi_fill_random\u751f\u6210\u968f\u673a\u6570) B --> |ECP_SHORTWEIERSTRASS|D(mbedtls_mpi_fill_random\u751f\u6210\u968f\u673a\u6570) C --> E(\u6700\u4f4e\u76842\u52303\u4f4d\u6e05\u96f6) D --> G(\u5982\u679c\u5931\u8d25\u91cd\u65b0\u751f\u6210) G --> H[\u8f93\u51fa] E --> H click C \"../../tools/mbedtls_mpi_fill_random\" click D \"../../tools/mbedtls_mpi_fill_random\"","title":"\u51fd\u6570\u6d41\u7a0b"},{"location":"tools/mbedtls_ecp_gen_privkey/#_2","text":"mbedtls_ecp_gen_privkey int mbedtls_ecp_gen_privkey ( const mbedtls_ecp_group * grp , mbedtls_mpi * d , int ( * f_rng )( void * , unsigned char * , size_t ), void * p_rng ) { int ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA ; size_t n_size ; ECP_VALIDATE_RET ( grp != NULL ); ECP_VALIDATE_RET ( d != NULL ); ECP_VALIDATE_RET ( f_rng != NULL ); n_size = ( grp -> nbits + 7 ) / 8 ; #if defined(ECP_MONTGOMERY) if ( ecp_get_type ( grp ) == ECP_TYPE_MONTGOMERY ) { /* [M225] page 5 */ size_t b ; do { MBEDTLS_MPI_CHK ( mbedtls_mpi_fill_random ( d , n_size , f_rng , p_rng ) ); } while ( mbedtls_mpi_bitlen ( d ) == 0 ); /* Make sure the most significant bit is nbits */ b = mbedtls_mpi_bitlen ( d ) - 1 ; /* mbedtls_mpi_bitlen is one-based */ if ( b > grp -> nbits ) MBEDTLS_MPI_CHK ( mbedtls_mpi_shift_r ( d , b - grp -> nbits ) ); else MBEDTLS_MPI_CHK ( mbedtls_mpi_set_bit ( d , grp -> nbits , 1 ) ); /* Make sure the last two bits are unset for Curve448, three bits for Curve25519 */ MBEDTLS_MPI_CHK ( mbedtls_mpi_set_bit ( d , 0 , 0 ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_set_bit ( d , 1 , 0 ) ); if ( grp -> nbits == 254 ) { MBEDTLS_MPI_CHK ( mbedtls_mpi_set_bit ( d , 2 , 0 ) ); } } #endif /* ECP_MONTGOMERY */ #if defined(ECP_SHORTWEIERSTRASS) if ( ecp_get_type ( grp ) == ECP_TYPE_SHORT_WEIERSTRASS ) { /* SEC1 3.2.1: Generate d such that 1 <= n < N */ int count = 0 ; /* * Match the procedure given in RFC 6979 (deterministic ECDSA): * - use the same byte ordering; * - keep the leftmost nbits bits of the generated octet string; * - try until result is in the desired range. * This also avoids any biais, which is especially important for ECDSA. */ do { MBEDTLS_MPI_CHK ( mbedtls_mpi_fill_random ( d , n_size , f_rng , p_rng ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_shift_r ( d , 8 * n_size - grp -> nbits ) ); /* * Each try has at worst a probability 1/2 of failing (the msb has * a probability 1/2 of being 0, and then the result will be < N), * so after 30 tries failure probability is a most 2**(-30). * * For most curves, 1 try is enough with overwhelming probability, * since N starts with a lot of 1s in binary, but some curves * such as secp224k1 are actually very close to the worst case. */ if ( ++ count > 30 ) return ( MBEDTLS_ERR_ECP_RANDOM_FAILED ); } while ( mbedtls_mpi_cmp_int ( d , 1 ) < 0 || mbedtls_mpi_cmp_mpi ( d , & grp -> N ) >= 0 ); } #endif /* ECP_SHORTWEIERSTRASS */ cleanup : return ( ret ); }","title":"\u51fd\u6570\u4ee3\u7801"},{"location":"tools/mbedtls_ecp_gen_privkey/#_3","text":"\u51fd\u6570\u6839\u636e\u4e0d\u540c\u7684\u66f2\u7ebf\u7c7b\u578b\u751f\u6210\u4e0d\u540c\u7684\u6ee1\u8db3\u8981\u6c42\u7684\u968f\u673a\u6570 \u66f2\u7ebf\u7c7b\u578b\u5305\u62ec\uff1a There are several different ways to express elliptic curves over F_p: The short Weierstrass equation y^2 = x^3 + ax + b, where 4a^3+27b^2 is nonzero in F_p, is an elliptic curve over F_p. Every elliptic curve over F_p can be converted to a short Weierstrass equation if p is larger than 3. The Montgomery equation By^2 = x^3 + Ax^2 + x, where B(A^2-4) is nonzero in F_p, is an elliptic curve over F_p. Substituting x = Bu-A/3 and y = Bv produces the short Weierstrass equation v^2 = u^3 + au + b where a = (3-A^2)/(3B^2) and b = (2A^3-9A)/(27B^3). Montgomery curves were introduced by 1987 Montgomery . The Edwards equation x^2 + y^2 = 1 + dx^2y^2, where d(1-d) is nonzero in F_p, is an elliptic curve over F_p. Substituting x = u/v and y = (u-1)/(u+1) produces the Montgomery equation Bv^2 = u^3 + Au^2 + u where A = 2(1+d)/(1-d) and B = 4/(1-d). Edwards curves were introduced by 2007 Edwards in the case that d is a 4th power. SafeCurves requires Edwards curves to be complete , i.e., for d to not be a square; complete Edwards curves were introduced by 2007 Bernstein\u2013Lange . \u5176\u4e2dmbedtls\u652f\u6301\u7684\u662f Montgomery equation \u548c short Weierstrass equation \u51fd\u6570\u7684\u6838\u5fc3\u4e3ambedtls_mpi_fill_random\u51fd\u6570 \u51fd\u6570\u5148\u8c03\u7528mbedtls_mpi_fill_random\u51fd\u6570\u751f\u6210\u968f\u673a\u6570\uff0c\u518d\u6839\u636e\u66f2\u7ebf\u7c7b\u578b\u8c03\u6574 \u4f8b\u5982\u5982\u679c\u692d\u5706\u66f2\u7ebf\u7c7b\u578b\u4e3a Montgomery\uff0c\u5219\u5c06\u6700\u4f4e\u76842\u52303\u4f4d\u6e05\u96f6","title":"\u51fd\u6570\u8bf4\u660e"},{"location":"tools/mbedtls_ecp_mul_restartable/","text":"mbedtls_ecp_mul_restartable\uff08ecp.c 2324\uff09 \u51fd\u6570\u6d41\u7a0b graph TB Z[mbedtls_ecp_mul_restartable\u51fd\u6570] A[\u8f93\u5165] -->B(\u5b9a\u4e49\u53d8\u91cf,\u68c0\u67e5\u5408\u6cd5\u6027) B --> C(\u5982\u679c\u5f00\u542frestartable\u5219\u5b58\u50a8\u72b6\u6001) C --> |ECP_MONTGOMERY|E[ecp_mul_mxz\u51fd\u6570] subgraph a E --> G(\u521d\u59cb\u5316) G --> H(\u968f\u673a\u5316\u4e34\u65f6\u70b9\u5750\u6807) H --> I(montgomery ladder\u8ba1\u7b97\u4e58\u6cd5) end I --> J[\u8f93\u51fa] C --> |ECP_SHORTWEIERSTRASS|F[ecp_mul_comb\u51fd\u6570] subgraph b F --> K(\u521d\u59cb\u5316\u548c\u65ad\u70b9) K --> L(\u751f\u6210\u9884\u8ba1\u7b97\u70b9\u8868) L --> M[ecp_mul_comb_after_precomp\u51fd\u6570] subgraph c M --> N(\u5bf9\u6807\u91cf\u503c\u8fdb\u884c\u7f16\u7801) N --> O(ecp_mul_comb_core\u51fd\u6570\u70b9\u4e58) O --> P(ecp_safe_invert_jac\u51fd\u6570\u96c5\u53ef\u6bd4\u5750\u6807\u7cfb\u5b89\u5168\u53cd\u8f6c) P --> Q(normalize) end end Q --> R[\u8f93\u51fa] click O \"../../tools/ecp_mul_comb_core\" click P \"../../tools/ecp_safe_invert_jac\" \u51fd\u6570\u4ee3\u7801 int mbedtls_ecp_mul_restartable ( mbedtls_ecp_group * grp , mbedtls_ecp_point * R , const mbedtls_mpi * m , const mbedtls_ecp_point * P , int ( * f_rng )( void * , unsigned char * , size_t ), void * p_rng , mbedtls_ecp_restart_ctx * rs_ctx ) { int ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA ; #if defined(MBEDTLS_ECP_INTERNAL_ALT) char is_grp_capable = 0 ; #endif ECP_VALIDATE_RET ( grp != NULL ); ECP_VALIDATE_RET ( R != NULL ); ECP_VALIDATE_RET ( m != NULL ); ECP_VALIDATE_RET ( P != NULL ); #if defined(MBEDTLS_ECP_RESTARTABLE) /* reset ops count for this call if top-level */ if ( rs_ctx != NULL && rs_ctx -> depth ++ == 0 ) rs_ctx -> ops_done = 0 ; #endif #if defined(MBEDTLS_ECP_INTERNAL_ALT) if ( ( is_grp_capable = mbedtls_internal_ecp_grp_capable ( grp ) ) ) MBEDTLS_MPI_CHK ( mbedtls_internal_ecp_init ( grp ) ); #endif /* MBEDTLS_ECP_INTERNAL_ALT */ #if defined(MBEDTLS_ECP_RESTARTABLE) /* skip argument check when restarting */ if ( rs_ctx == NULL || rs_ctx -> rsm == NULL ) #endif { /* check_privkey is free */ MBEDTLS_ECP_BUDGET ( MBEDTLS_ECP_OPS_CHK ); /* Common sanity checks */ MBEDTLS_MPI_CHK ( mbedtls_ecp_check_privkey ( grp , m ) ); MBEDTLS_MPI_CHK ( mbedtls_ecp_check_pubkey ( grp , P ) ); } ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA ; #if defined(ECP_MONTGOMERY) if ( ecp_get_type ( grp ) == ECP_TYPE_MONTGOMERY ) MBEDTLS_MPI_CHK ( ecp_mul_mxz ( grp , R , m , P , f_rng , p_rng ) ); #endif #if defined(ECP_SHORTWEIERSTRASS) if ( ecp_get_type ( grp ) == ECP_TYPE_SHORT_WEIERSTRASS ) MBEDTLS_MPI_CHK ( ecp_mul_comb ( grp , R , m , P , f_rng , p_rng , rs_ctx ) ); #endif cleanup : #if defined(MBEDTLS_ECP_INTERNAL_ALT) if ( is_grp_capable ) mbedtls_internal_ecp_free ( grp ); #endif /* MBEDTLS_ECP_INTERNAL_ALT */ #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL ) rs_ctx -> depth -- ; #endif return ( ret ); } \u51fd\u6570\u8bf4\u660e \u7528\u4e8e\u6267\u884c\u692d\u5706\u66f2\u7ebf\u4e0a\u7684\u4e58\u6cd5\u64cd\u4f5c \u6839\u636e\u66f2\u7ebf\u5206\u7c7b\u8c03\u7528\u4e0d\u540c\u7684\u5904\u7406\u51fd\u6570\uff0c\u5982\u679c\u662fmontgomery\u5219\u8c03\u7528ecp_mul_mxz\uff0c\u53cd\u4e4b\u8c03\u7528ecp_mul_comb ecp_mul_mxz\u51fd\u6570\u4ee3\u7801(ecp.c 2263) static int ecp_mul_mxz ( mbedtls_ecp_group * grp , mbedtls_ecp_point * R , const mbedtls_mpi * m , const mbedtls_ecp_point * P , int ( * f_rng )( void * , unsigned char * , size_t ), void * p_rng ) { int ret ; size_t i ; unsigned char b ; mbedtls_ecp_point RP ; mbedtls_mpi PX ; mbedtls_ecp_point_init ( & RP ); mbedtls_mpi_init ( & PX ); /* Save PX and read from P before writing to R, in case P == R */ MBEDTLS_MPI_CHK ( mbedtls_mpi_copy ( & PX , & P -> X ) ); MBEDTLS_MPI_CHK ( mbedtls_ecp_copy ( & RP , P ) ); /* Set R to zero in modified x/z coordinates */ MBEDTLS_MPI_CHK ( mbedtls_mpi_lset ( & R -> X , 1 ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_lset ( & R -> Z , 0 ) ); mbedtls_mpi_free ( & R -> Y ); /* RP.X might be sligtly larger than P, so reduce it */ MOD_ADD ( RP . X ); /* Randomize coordinates of the starting point */ if ( f_rng != NULL ) MBEDTLS_MPI_CHK ( ecp_randomize_mxz ( grp , & RP , f_rng , p_rng ) ); /* Loop invariant: R = result so far, RP = R + P */ i = mbedtls_mpi_bitlen ( m ); /* one past the (zero-based) most significant bit */ while ( i -- > 0 ) { b = mbedtls_mpi_get_bit ( m , i ); /* * if (b) R = 2R + P else R = 2R, * which is: * if (b) double_add( RP, R, RP, R ) * else double_add( R, RP, R, RP ) * but using safe conditional swaps to avoid leaks */ MBEDTLS_MPI_CHK ( mbedtls_mpi_safe_cond_swap ( & R -> X , & RP . X , b ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_safe_cond_swap ( & R -> Z , & RP . Z , b ) ); MBEDTLS_MPI_CHK ( ecp_double_add_mxz ( grp , R , & RP , R , & RP , & PX ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_safe_cond_swap ( & R -> X , & RP . X , b ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_safe_cond_swap ( & R -> Z , & RP . Z , b ) ); } MBEDTLS_MPI_CHK ( ecp_normalize_mxz ( grp , R ) ); cleanup : mbedtls_ecp_point_free ( & RP ); mbedtls_mpi_free ( & PX ); return ( ret ); } ecp_mul_mxz\u51fd\u6570\u8bf4\u660e \u51fd\u6570\u7684\u8f93\u5165\u53c2\u6570\u5305\u62ec\u692d\u5706\u66f2\u7ebf\u7fa4 grp\u3001\u7ed3\u679c\u5b58\u50a8\u70b9 R\u3001\u4e58\u6570 m\u3001\u88ab\u4e58\u70b9 P\u3001\u968f\u673a\u6570\u751f\u6210\u51fd\u6570 f_rng \u548c\u968f\u673a\u6570\u751f\u6210\u5668\u4e0a\u4e0b\u6587\u6307\u9488 p_rng\u3002 \u51fd\u6570\u9996\u5148\u521d\u59cb\u5316\u4e00\u4e9b\u53d8\u91cf\u548c\u6570\u636e\u7ed3\u6784\u3002\u7136\u540e\uff0c\u51fd\u6570\u4fdd\u5b58\u4e86\u70b9 P \u7684 x \u5750\u6807\uff0c\u5e76\u5c06\u70b9 P \u590d\u5236\u5230\u4e34\u65f6\u70b9 RP\u4e2d\uff0c\u4ee5\u4fbf\u5728\u8ba1\u7b97\u8fc7\u7a0b\u4e2d\u4fdd\u6301\u4e0d\u53d8\u3002 \u63a5\u7740\uff0c\u51fd\u6570\u5c06\u70b9 R \u7684 x/z \u5750\u6807\u8bbe\u7f6e\u4e3a 1 \u548c 0\uff0c\u5e76\u91ca\u653e\u70b9 R \u7684 y \u5750\u6807\u3002\u8fd9\u662f \"Montgomery ladder\" \u7b97\u6cd5\u7684\u521d\u59cb\u5316\u6b65\u9aa4\u3002 \u7136\u540e\uff0c\u51fd\u6570\u5bf9\u4e34\u65f6\u70b9 RP \u7684 x \u5750\u6807\u6267\u884c\u6a21\u8fd0\u7b97\uff0c\u4ee5\u786e\u4fdd\u8be5\u503c\u5728\u692d\u5706\u66f2\u7ebf\u7684\u5b9a\u4e49\u57df\u5185\u3002 \u63a5\u4e0b\u6765\uff0c\u51fd\u6570\u4f7f\u7528\u968f\u673a\u6570\u751f\u6210\u51fd\u6570 f_rng \u968f\u673a\u5316\u4e34\u65f6\u70b9 RP\u7684 x/z \u5750\u6807\uff0c\u4ece\u800c\u589e\u52a0\u653b\u51fb\u96be\u5ea6\u3002\uff08\u4fa7\u4fe1\u9053\u4fdd\u62a4\u673a\u5236\uff09 \u7136\u540e\uff0c\u51fd\u6570\u6839\u636e\u4e58\u6570 m\u7684\u4e8c\u8fdb\u5236\u8868\u793a\u5f62\u5f0f\uff0c\u4f7f\u7528 \"Montgomery ladder\" \u7b97\u6cd5\u6765\u8ba1\u7b97\u70b9 R\u7684\u503c\u3002(\u53ef\u66ff\u6362\u4e3a\u666e\u901a\u5b9e\u73b0) Montgomery ladder \u7b97\u6cd5\u7684\u57fa\u672c\u601d\u60f3\uff1a \u5c06\u70b9 P \u7528 Montgomery representation \u8868\u793a\u4e3a (X1:Z1)\uff0c\u5176\u4e2d X1 \u548c Z1 \u90fd\u662f\u6574\u6570\u3002 \u521d\u59cb\u5316\u4e24\u4e2a\u70b9\uff0cR0 = (1:0) \u548c R1 = (X1:1)\u3002 \u4ece m \u7684\u6700\u9ad8\u4f4d\u5f00\u59cb\uff0c\u5bf9\u6bcf\u4e00\u4f4d\u8fdb\u884c\u5904\u7406\uff1a \u5982\u679c\u8be5\u4f4d\u4e3a 0\uff0c\u5219\u5c06 R1 \u52a0\u500d\uff0c\u5e76\u5c06 R0 \u548c R1 \u4ea4\u6362\u3002 \u5982\u679c\u8be5\u4f4d\u4e3a 1\uff0c\u5219\u5c06 R0 \u4e0e R1 \u76f8\u52a0\uff0c\u5e76\u5c06 R0 \u548c R1 \u4ea4\u6362\u3002 \u8fd4\u56de R0\u3002 \u6700\u540e\uff0c\u51fd\u6570\u5bf9\u70b9 R \u8fdb\u884c\u5f52\u4e00\u5316\uff0c\u4ee5\u786e\u4fdd\u5b83\u5728\u692d\u5706\u66f2\u7ebf\u7684\u5b9a\u4e49\u57df\u5185\u3002\u7136\u540e\uff0c\u51fd\u6570\u91ca\u653e\u5185\u5b58\u5e76\u8fd4\u56de\u7ed3\u679c\u3002 ecp_mul_comb\u51fd\u6570\u4ee3\u7801(ecp.c 2001) static int ecp_mul_comb ( mbedtls_ecp_group * grp , mbedtls_ecp_point * R , const mbedtls_mpi * m , const mbedtls_ecp_point * P , int ( * f_rng )( void * , unsigned char * , size_t ), void * p_rng , mbedtls_ecp_restart_ctx * rs_ctx ) { int ret ; unsigned char w , p_eq_g , i ; size_t d ; unsigned char T_size , T_ok ; mbedtls_ecp_point * T ; ECP_RS_ENTER ( rsm ); /* Is P the base point ? */ #if MBEDTLS_ECP_FIXED_POINT_OPTIM == 1 p_eq_g = ( mbedtls_mpi_cmp_mpi ( & P -> Y , & grp -> G . Y ) == 0 && mbedtls_mpi_cmp_mpi ( & P -> X , & grp -> G . X ) == 0 ); #else p_eq_g = 0 ; #endif /* Pick window size and deduce related sizes */ w = ecp_pick_window_size ( grp , p_eq_g ); T_size = 1U << ( w - 1 ); d = ( grp -> nbits + w - 1 ) / w ; /* Pre-computed table: do we have it already for the base point? */ if ( p_eq_g && grp -> T != NULL ) { /* second pointer to the same table, will be deleted on exit */ T = grp -> T ; T_ok = 1 ; } else #if defined(MBEDTLS_ECP_RESTARTABLE) /* Pre-computed table: do we have one in progress? complete? */ if ( rs_ctx != NULL && rs_ctx -> rsm != NULL && rs_ctx -> rsm -> T != NULL ) { /* transfer ownership of T from rsm to local function */ T = rs_ctx -> rsm -> T ; rs_ctx -> rsm -> T = NULL ; rs_ctx -> rsm -> T_size = 0 ; /* This effectively jumps to the call to mul_comb_after_precomp() */ T_ok = rs_ctx -> rsm -> state >= ecp_rsm_comb_core ; } else #endif /* Allocate table if we didn't have any */ { T = mbedtls_calloc ( T_size , sizeof ( mbedtls_ecp_point ) ); if ( T == NULL ) { ret = MBEDTLS_ERR_ECP_ALLOC_FAILED ; goto cleanup ; } for ( i = 0 ; i < T_size ; i ++ ) mbedtls_ecp_point_init ( & T [ i ] ); T_ok = 0 ; } /* Compute table (or finish computing it) if not done already */ if ( ! T_ok ) { MBEDTLS_MPI_CHK ( ecp_precompute_comb ( grp , T , P , w , d , rs_ctx ) ); if ( p_eq_g ) { /* almost transfer ownership of T to the group, but keep a copy of * the pointer to use for calling the next function more easily */ grp -> T = T ; grp -> T_size = T_size ; } } /* Actual comb multiplication using precomputed points */ MBEDTLS_MPI_CHK ( ecp_mul_comb_after_precomp ( grp , R , m , T , T_size , w , d , f_rng , p_rng , rs_ctx ) ); cleanup : /* does T belong to the group? */ if ( T == grp -> T ) T = NULL ; ecp_mul_comb\u51fd\u6570\u8bf4\u660e \u692d\u5706\u66f2\u7ebf\u4e0a\u7684\u70b9\u4e58\u6cd5\u8fd0\u7b97\uff0c\u4f7f\u7528\u4e86\u7ec4\u5408\u7b97\u6cd5\uff08Comb method\uff09\u6765\u4f18\u5316\u8ba1\u7b97\u6548\u7387\u3002 \u9996\u5148\uff0c\u51fd\u6570\u58f0\u660e\u4e86\u4e00\u4e9b\u53d8\u91cf\u548c\u6307\u9488\uff0c\u5982\u679c\u5f00\u542f\u4e86restartable\u5219\u8bb0\u5f55\u65ad\u70b9\u3002 \u51fd\u6570\u68c0\u67e5\u70b9 P \u662f\u5426\u4e3a\u57fa\u70b9\uff0c\u5373 P \u662f\u5426\u4e0e\u692d\u5706\u66f2\u7ebf\u7fa4\u7684\u57fa\u70b9 G \u76f8\u7b49\u3002\u5982\u679c MBEDTLS_ECP_FIXED_POINT_OPTIM \u5b9a\u4e49\u4e3a 1\uff0c\u5e76\u4e14 P \u7684\u5750\u6807\u4e0e G \u7684\u5750\u6807\u76f8\u7b49\uff0c\u5219\u5c06 p_eq_g \u8bbe\u7f6e\u4e3a 1\uff1b\u5426\u5219\u8bbe\u7f6e\u4e3a 0\u3002 \u51fd\u6570\u8c03\u7528 ecp_pick_window_size \u6765\u9009\u62e9\u7a97\u53e3\u5927\u5c0f\uff0c\u7a97\u53e3\u5927\u5c0f\u7684\u9009\u62e9\u53d6\u51b3\u4e8e p_eq_g \u7684\u503c\u548c\u692d\u5706\u66f2\u7ebf\u7fa4\u7684\u53c2\u6570\u3002\u7a97\u53e3\u5927\u5c0f\u51b3\u5b9a\u4e86\u9884\u8ba1\u7b97\u8868\u7684\u5927\u5c0f\u3002 \u6839\u636e\u7a97\u53e3\u5927\u5c0f\u8ba1\u7b97\u9884\u8ba1\u7b97\u8868\u7684\u5927\u5c0f\uff0c\u5e76\u8ba1\u7b97 d \u7684\u503c\uff0c d \u8868\u793a\u6807\u91cf\u503c\u7684\u4f4d\u6570\u9664\u4ee5\u7a97\u53e3\u5927\u5c0f\u540e\u7684\u7ed3\u679c\u3002 \u51fd\u6570\u6839\u636e\u662f\u5426\u5df2\u7ecf\u5b58\u5728\u57fa\u70b9\u7684\u9884\u8ba1\u7b97\u8868\u6765\u5224\u65ad\u662f\u5426\u9700\u8981\u8fdb\u884c\u9884\u8ba1\u7b97\u8868\u7684\u751f\u6210\uff1a \u5982\u679c p_eq_g \u4e3a\u771f\u4e14 grp->T \u4e0d\u4e3a\u7a7a\uff0c\u5219\u76f4\u63a5\u4f7f\u7528 grp->T \u4f5c\u4e3a\u9884\u8ba1\u7b97\u8868\uff0c\u5e76\u5c06 T_ok \u8bbe\u7f6e\u4e3a 1\u3002 \u5426\u5219\uff0c\u5982\u679c\u542f\u7528\u4e86\u91cd\u542f\u529f\u80fd\uff0c\u5e76\u4e14\u5b58\u5728\u6b63\u5728\u8fdb\u884c\u7684\u9884\u8ba1\u7b97\u8868\uff0c\u5219\u5c06\u9884\u8ba1\u7b97\u8868\u4ece rs_ctx \u4e2d\u8f6c\u79fb\u5230\u672c\u5730\u53d8\u91cf T \u4e2d\uff0c\u5e76\u5c06 T_ok \u8bbe\u7f6e\u4e3a 1\u3002 \u5426\u5219\uff0c\u5206\u914d T_size \u5927\u5c0f\u7684\u5185\u5b58\u7528\u4e8e\u5b58\u50a8\u9884\u8ba1\u7b97\u8868\uff0c\u5e76\u521d\u59cb\u5316\u9884\u8ba1\u7b97\u8868\u4e2d\u7684\u70b9\u3002 \u5982\u679c\u5185\u5b58\u5206\u914d\u5931\u8d25\uff0c\u5219\u8fd4\u56de MBEDTLS_ERR_ECP_ALLOC_FAILED \u9519\u8bef\u3002 \u5982\u679c\u9884\u8ba1\u7b97\u8868\u4e0d\u5b58\u5728\u6216\u8005\u9700\u8981\u91cd\u65b0\u8ba1\u7b97\uff0c\u8c03\u7528 ecp_precompute_comb \u51fd\u6570\u751f\u6210\u9884\u8ba1\u7b97\u8868\u3002\u8be5\u51fd\u6570\u4f7f\u7528\u7ec4\u5408\u7b97\u6cd5\uff08Comb method\uff09\u6765\u751f\u6210\u9884\u8ba1\u7b97\u8868\uff0c\u63d0\u524d\u8ba1\u7b97\u51fa\u4e00\u7cfb\u5217\u70b9\u7684\u5750\u6807\uff0c\u4ee5\u7528\u4e8e\u540e\u7eed\u7684\u70b9\u4e58\u6cd5\u8fd0\u7b97\u3002\u751f\u6210\u9884\u8ba1\u7b97\u8868\u7684\u8fc7\u7a0b\u53ef\u80fd\u4f1a\u6d89\u53ca\u5230\u91cd\u542f\u529f\u80fd\u3002 \u5982\u679c P \u662f\u57fa\u70b9\uff0c\u5219\u5c06 T \u7684\u6240\u6709\u6743\u8f6c\u79fb\u5230\u7fa4\u7ed3\u6784\u4f53 grp \u4e2d\uff0c\u5e76\u5c06 grp->T \u548c grp->T_size \u8bbe\u7f6e\u4e3a\u76f8\u5e94\u7684\u503c\u3002 \u6700\u540e\uff0c\u8c03\u7528 ecp_mul_comb_after_precomp \u51fd\u6570\u6267\u884c\u57fa\u4e8e\u9884\u8ba1\u7b97\u8868\u7684\u70b9\u4e58\u6cd5\u8fd0\u7b97\u3002\u8be5\u51fd\u6570\u4f7f\u7528\u9884\u8ba1\u7b97\u8868\u4e2d\u7684\u70b9\u8fdb\u884c\u70b9\u4e58\u6cd5\u8fd0\u7b97\uff0c\u53ef\u4ee5\u5927\u5927\u63d0\u9ad8\u8ba1\u7b97\u6548\u7387\u3002\u8fd0\u7b97\u7ed3\u679c\u5b58\u50a8\u5728 R \u4e2d\u3002 \u6e05\u7406\u9636\u6bb5\uff0c\u91ca\u653e\u9884\u8ba1\u7b97\u8868\u7684\u5185\u5b58\u8d44\u6e90\uff0c\u5e76\u6839\u636e T \u662f\u5426\u5c5e\u4e8e\u7fa4\u7ed3\u6784\u4f53 grp \u6765\u786e\u5b9a\u662f\u5426\u5c06 T \u8bbe\u7f6e\u4e3a NULL\u3002 \u5176\u4e2d\u6838\u5fc3\u51fd\u6570\u4e3aecp_mul_comb_after_precomp ecp_mul_comb_after_precomp\u51fd\u6570\u4ee3\u7801\uff08ecp.c 1903\uff09 static int ecp_mul_comb_after_precomp ( const mbedtls_ecp_group * grp , mbedtls_ecp_point * R , const mbedtls_mpi * m , const mbedtls_ecp_point * T , unsigned char T_size , unsigned char w , size_t d , int ( * f_rng )( void * , unsigned char * , size_t ), void * p_rng , mbedtls_ecp_restart_ctx * rs_ctx ) { int ret ; unsigned char parity_trick ; unsigned char k [ COMB_MAX_D + 1 ]; mbedtls_ecp_point * RR = R ; #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> rsm != NULL ) { RR = & rs_ctx -> rsm -> R ; if ( rs_ctx -> rsm -> state == ecp_rsm_final_norm ) goto final_norm ; } #endif MBEDTLS_MPI_CHK ( ecp_comb_recode_scalar ( grp , m , k , d , w , & parity_trick ) ); MBEDTLS_MPI_CHK ( ecp_mul_comb_core ( grp , RR , T , T_size , k , d , f_rng , p_rng , rs_ctx ) ); MBEDTLS_MPI_CHK ( ecp_safe_invert_jac ( grp , RR , parity_trick ) ); #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> rsm != NULL ) rs_ctx -> rsm -> state = ecp_rsm_final_norm ; final_norm : #endif MBEDTLS_ECP_BUDGET ( MBEDTLS_ECP_OPS_INV ); MBEDTLS_MPI_CHK ( ecp_normalize_jac ( grp , RR ) ); #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> rsm != NULL ) MBEDTLS_MPI_CHK ( mbedtls_ecp_copy ( R , RR ) ); #endif cleanup : return ( ret ); } ecp_mul_comb_after_precomp\u51fd\u6570\u8bf4\u660e \u9996\u5148\uff0c\u51fd\u6570\u58f0\u660e\u4e86\u4e00\u4e9b\u53d8\u91cf\u548c\u6307\u9488\uff0c\u5982\u679c\u5f00\u542f\u4e86restartable\u5219\u8bb0\u5f55\u65ad\u70b9\u3002 \u8c03\u7528ecp_comb_recode_scalar\u51fd\u6570\u5bf9\u6807\u91cf\u503c\u8fdb\u884c\u7f16\u7801\uff0c\u5f97\u5230\u9884\u8ba1\u7b97\u7684\u7a97\u53e3\u8868 \u8c03\u7528ecp_mul_comb_core\u51fd\u6570\u6267\u884c\u70b9\u4e58\u6cd5\u8fd0\u7b97\uff0c\u4f7f\u7528\u9884\u8ba1\u7b97\u7684\u7a97\u53e3\u8868\u548c\u7f16\u7801\u540e\u7684\u6807\u91cf\u503c\u3002 \u8c03\u7528ecp_safe_invert_jac\u51fd\u6570\u5bf9\u7ed3\u679c\u70b9\u8fdb\u884c\u96c5\u53ef\u6bd4\u5750\u6807\u7cfb\u4e0b\u7684\u5b89\u5168\u53cd\u8f6c\uff08inversion\uff09\u64cd\u4f5c\uff0c\u4ee5\u786e\u4fdd\u7ed3\u679c\u7684\u6b63\u786e\u6027\u3002 \u6267\u884cecp_normalize_jac\u51fd\u6570\u5bf9\u7ed3\u679c\u70b9\u8fdb\u884c\u89c4\u8303\u5316\u64cd\u4f5c\uff0c\u5c06\u7ed3\u679c\u70b9\u4ece\u96c5\u53ef\u6bd4\u5750\u6807\u7cfb\u8f6c\u6362\u4e3a\u4eff\u5c04\u5750\u6807\u7cfb\u3002 \u5982\u679c\u542f\u7528\u4e86\u91cd\u542f\u673a\u5236\uff0c\u5c06\u89c4\u8303\u5316\u540e\u7684\u7ed3\u679c\u70b9\u62f7\u8d1d\u5230\u8f93\u51fa\u53c2\u6570R\u4e2d\u3002 \u8fd4\u56de\u6267\u884c\u7ed3\u679c\u3002","title":"mbedtls_ecp_mul_restartable"},{"location":"tools/mbedtls_ecp_mul_restartable/#mbedtls_ecp_mul_restartableecpc-2324","text":"","title":"mbedtls_ecp_mul_restartable\uff08ecp.c 2324\uff09"},{"location":"tools/mbedtls_ecp_mul_restartable/#_1","text":"graph TB Z[mbedtls_ecp_mul_restartable\u51fd\u6570] A[\u8f93\u5165] -->B(\u5b9a\u4e49\u53d8\u91cf,\u68c0\u67e5\u5408\u6cd5\u6027) B --> C(\u5982\u679c\u5f00\u542frestartable\u5219\u5b58\u50a8\u72b6\u6001) C --> |ECP_MONTGOMERY|E[ecp_mul_mxz\u51fd\u6570] subgraph a E --> G(\u521d\u59cb\u5316) G --> H(\u968f\u673a\u5316\u4e34\u65f6\u70b9\u5750\u6807) H --> I(montgomery ladder\u8ba1\u7b97\u4e58\u6cd5) end I --> J[\u8f93\u51fa] C --> |ECP_SHORTWEIERSTRASS|F[ecp_mul_comb\u51fd\u6570] subgraph b F --> K(\u521d\u59cb\u5316\u548c\u65ad\u70b9) K --> L(\u751f\u6210\u9884\u8ba1\u7b97\u70b9\u8868) L --> M[ecp_mul_comb_after_precomp\u51fd\u6570] subgraph c M --> N(\u5bf9\u6807\u91cf\u503c\u8fdb\u884c\u7f16\u7801) N --> O(ecp_mul_comb_core\u51fd\u6570\u70b9\u4e58) O --> P(ecp_safe_invert_jac\u51fd\u6570\u96c5\u53ef\u6bd4\u5750\u6807\u7cfb\u5b89\u5168\u53cd\u8f6c) P --> Q(normalize) end end Q --> R[\u8f93\u51fa] click O \"../../tools/ecp_mul_comb_core\" click P \"../../tools/ecp_safe_invert_jac\"","title":"\u51fd\u6570\u6d41\u7a0b"},{"location":"tools/mbedtls_ecp_mul_restartable/#_2","text":"int mbedtls_ecp_mul_restartable ( mbedtls_ecp_group * grp , mbedtls_ecp_point * R , const mbedtls_mpi * m , const mbedtls_ecp_point * P , int ( * f_rng )( void * , unsigned char * , size_t ), void * p_rng , mbedtls_ecp_restart_ctx * rs_ctx ) { int ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA ; #if defined(MBEDTLS_ECP_INTERNAL_ALT) char is_grp_capable = 0 ; #endif ECP_VALIDATE_RET ( grp != NULL ); ECP_VALIDATE_RET ( R != NULL ); ECP_VALIDATE_RET ( m != NULL ); ECP_VALIDATE_RET ( P != NULL ); #if defined(MBEDTLS_ECP_RESTARTABLE) /* reset ops count for this call if top-level */ if ( rs_ctx != NULL && rs_ctx -> depth ++ == 0 ) rs_ctx -> ops_done = 0 ; #endif #if defined(MBEDTLS_ECP_INTERNAL_ALT) if ( ( is_grp_capable = mbedtls_internal_ecp_grp_capable ( grp ) ) ) MBEDTLS_MPI_CHK ( mbedtls_internal_ecp_init ( grp ) ); #endif /* MBEDTLS_ECP_INTERNAL_ALT */ #if defined(MBEDTLS_ECP_RESTARTABLE) /* skip argument check when restarting */ if ( rs_ctx == NULL || rs_ctx -> rsm == NULL ) #endif { /* check_privkey is free */ MBEDTLS_ECP_BUDGET ( MBEDTLS_ECP_OPS_CHK ); /* Common sanity checks */ MBEDTLS_MPI_CHK ( mbedtls_ecp_check_privkey ( grp , m ) ); MBEDTLS_MPI_CHK ( mbedtls_ecp_check_pubkey ( grp , P ) ); } ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA ; #if defined(ECP_MONTGOMERY) if ( ecp_get_type ( grp ) == ECP_TYPE_MONTGOMERY ) MBEDTLS_MPI_CHK ( ecp_mul_mxz ( grp , R , m , P , f_rng , p_rng ) ); #endif #if defined(ECP_SHORTWEIERSTRASS) if ( ecp_get_type ( grp ) == ECP_TYPE_SHORT_WEIERSTRASS ) MBEDTLS_MPI_CHK ( ecp_mul_comb ( grp , R , m , P , f_rng , p_rng , rs_ctx ) ); #endif cleanup : #if defined(MBEDTLS_ECP_INTERNAL_ALT) if ( is_grp_capable ) mbedtls_internal_ecp_free ( grp ); #endif /* MBEDTLS_ECP_INTERNAL_ALT */ #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL ) rs_ctx -> depth -- ; #endif return ( ret ); }","title":"\u51fd\u6570\u4ee3\u7801"},{"location":"tools/mbedtls_ecp_mul_restartable/#_3","text":"\u7528\u4e8e\u6267\u884c\u692d\u5706\u66f2\u7ebf\u4e0a\u7684\u4e58\u6cd5\u64cd\u4f5c \u6839\u636e\u66f2\u7ebf\u5206\u7c7b\u8c03\u7528\u4e0d\u540c\u7684\u5904\u7406\u51fd\u6570\uff0c\u5982\u679c\u662fmontgomery\u5219\u8c03\u7528ecp_mul_mxz\uff0c\u53cd\u4e4b\u8c03\u7528ecp_mul_comb","title":"\u51fd\u6570\u8bf4\u660e"},{"location":"tools/mbedtls_ecp_mul_restartable/#ecp_mul_mxzecpc-2263","text":"static int ecp_mul_mxz ( mbedtls_ecp_group * grp , mbedtls_ecp_point * R , const mbedtls_mpi * m , const mbedtls_ecp_point * P , int ( * f_rng )( void * , unsigned char * , size_t ), void * p_rng ) { int ret ; size_t i ; unsigned char b ; mbedtls_ecp_point RP ; mbedtls_mpi PX ; mbedtls_ecp_point_init ( & RP ); mbedtls_mpi_init ( & PX ); /* Save PX and read from P before writing to R, in case P == R */ MBEDTLS_MPI_CHK ( mbedtls_mpi_copy ( & PX , & P -> X ) ); MBEDTLS_MPI_CHK ( mbedtls_ecp_copy ( & RP , P ) ); /* Set R to zero in modified x/z coordinates */ MBEDTLS_MPI_CHK ( mbedtls_mpi_lset ( & R -> X , 1 ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_lset ( & R -> Z , 0 ) ); mbedtls_mpi_free ( & R -> Y ); /* RP.X might be sligtly larger than P, so reduce it */ MOD_ADD ( RP . X ); /* Randomize coordinates of the starting point */ if ( f_rng != NULL ) MBEDTLS_MPI_CHK ( ecp_randomize_mxz ( grp , & RP , f_rng , p_rng ) ); /* Loop invariant: R = result so far, RP = R + P */ i = mbedtls_mpi_bitlen ( m ); /* one past the (zero-based) most significant bit */ while ( i -- > 0 ) { b = mbedtls_mpi_get_bit ( m , i ); /* * if (b) R = 2R + P else R = 2R, * which is: * if (b) double_add( RP, R, RP, R ) * else double_add( R, RP, R, RP ) * but using safe conditional swaps to avoid leaks */ MBEDTLS_MPI_CHK ( mbedtls_mpi_safe_cond_swap ( & R -> X , & RP . X , b ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_safe_cond_swap ( & R -> Z , & RP . Z , b ) ); MBEDTLS_MPI_CHK ( ecp_double_add_mxz ( grp , R , & RP , R , & RP , & PX ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_safe_cond_swap ( & R -> X , & RP . X , b ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_safe_cond_swap ( & R -> Z , & RP . Z , b ) ); } MBEDTLS_MPI_CHK ( ecp_normalize_mxz ( grp , R ) ); cleanup : mbedtls_ecp_point_free ( & RP ); mbedtls_mpi_free ( & PX ); return ( ret ); }","title":"ecp_mul_mxz\u51fd\u6570\u4ee3\u7801(ecp.c 2263)"},{"location":"tools/mbedtls_ecp_mul_restartable/#ecp_mul_mxz","text":"\u51fd\u6570\u7684\u8f93\u5165\u53c2\u6570\u5305\u62ec\u692d\u5706\u66f2\u7ebf\u7fa4 grp\u3001\u7ed3\u679c\u5b58\u50a8\u70b9 R\u3001\u4e58\u6570 m\u3001\u88ab\u4e58\u70b9 P\u3001\u968f\u673a\u6570\u751f\u6210\u51fd\u6570 f_rng \u548c\u968f\u673a\u6570\u751f\u6210\u5668\u4e0a\u4e0b\u6587\u6307\u9488 p_rng\u3002 \u51fd\u6570\u9996\u5148\u521d\u59cb\u5316\u4e00\u4e9b\u53d8\u91cf\u548c\u6570\u636e\u7ed3\u6784\u3002\u7136\u540e\uff0c\u51fd\u6570\u4fdd\u5b58\u4e86\u70b9 P \u7684 x \u5750\u6807\uff0c\u5e76\u5c06\u70b9 P \u590d\u5236\u5230\u4e34\u65f6\u70b9 RP\u4e2d\uff0c\u4ee5\u4fbf\u5728\u8ba1\u7b97\u8fc7\u7a0b\u4e2d\u4fdd\u6301\u4e0d\u53d8\u3002 \u63a5\u7740\uff0c\u51fd\u6570\u5c06\u70b9 R \u7684 x/z \u5750\u6807\u8bbe\u7f6e\u4e3a 1 \u548c 0\uff0c\u5e76\u91ca\u653e\u70b9 R \u7684 y \u5750\u6807\u3002\u8fd9\u662f \"Montgomery ladder\" \u7b97\u6cd5\u7684\u521d\u59cb\u5316\u6b65\u9aa4\u3002 \u7136\u540e\uff0c\u51fd\u6570\u5bf9\u4e34\u65f6\u70b9 RP \u7684 x \u5750\u6807\u6267\u884c\u6a21\u8fd0\u7b97\uff0c\u4ee5\u786e\u4fdd\u8be5\u503c\u5728\u692d\u5706\u66f2\u7ebf\u7684\u5b9a\u4e49\u57df\u5185\u3002 \u63a5\u4e0b\u6765\uff0c\u51fd\u6570\u4f7f\u7528\u968f\u673a\u6570\u751f\u6210\u51fd\u6570 f_rng \u968f\u673a\u5316\u4e34\u65f6\u70b9 RP\u7684 x/z \u5750\u6807\uff0c\u4ece\u800c\u589e\u52a0\u653b\u51fb\u96be\u5ea6\u3002\uff08\u4fa7\u4fe1\u9053\u4fdd\u62a4\u673a\u5236\uff09 \u7136\u540e\uff0c\u51fd\u6570\u6839\u636e\u4e58\u6570 m\u7684\u4e8c\u8fdb\u5236\u8868\u793a\u5f62\u5f0f\uff0c\u4f7f\u7528 \"Montgomery ladder\" \u7b97\u6cd5\u6765\u8ba1\u7b97\u70b9 R\u7684\u503c\u3002(\u53ef\u66ff\u6362\u4e3a\u666e\u901a\u5b9e\u73b0) Montgomery ladder \u7b97\u6cd5\u7684\u57fa\u672c\u601d\u60f3\uff1a \u5c06\u70b9 P \u7528 Montgomery representation \u8868\u793a\u4e3a (X1:Z1)\uff0c\u5176\u4e2d X1 \u548c Z1 \u90fd\u662f\u6574\u6570\u3002 \u521d\u59cb\u5316\u4e24\u4e2a\u70b9\uff0cR0 = (1:0) \u548c R1 = (X1:1)\u3002 \u4ece m \u7684\u6700\u9ad8\u4f4d\u5f00\u59cb\uff0c\u5bf9\u6bcf\u4e00\u4f4d\u8fdb\u884c\u5904\u7406\uff1a \u5982\u679c\u8be5\u4f4d\u4e3a 0\uff0c\u5219\u5c06 R1 \u52a0\u500d\uff0c\u5e76\u5c06 R0 \u548c R1 \u4ea4\u6362\u3002 \u5982\u679c\u8be5\u4f4d\u4e3a 1\uff0c\u5219\u5c06 R0 \u4e0e R1 \u76f8\u52a0\uff0c\u5e76\u5c06 R0 \u548c R1 \u4ea4\u6362\u3002 \u8fd4\u56de R0\u3002 \u6700\u540e\uff0c\u51fd\u6570\u5bf9\u70b9 R \u8fdb\u884c\u5f52\u4e00\u5316\uff0c\u4ee5\u786e\u4fdd\u5b83\u5728\u692d\u5706\u66f2\u7ebf\u7684\u5b9a\u4e49\u57df\u5185\u3002\u7136\u540e\uff0c\u51fd\u6570\u91ca\u653e\u5185\u5b58\u5e76\u8fd4\u56de\u7ed3\u679c\u3002","title":"ecp_mul_mxz\u51fd\u6570\u8bf4\u660e"},{"location":"tools/mbedtls_ecp_mul_restartable/#ecp_mul_combecpc-2001","text":"static int ecp_mul_comb ( mbedtls_ecp_group * grp , mbedtls_ecp_point * R , const mbedtls_mpi * m , const mbedtls_ecp_point * P , int ( * f_rng )( void * , unsigned char * , size_t ), void * p_rng , mbedtls_ecp_restart_ctx * rs_ctx ) { int ret ; unsigned char w , p_eq_g , i ; size_t d ; unsigned char T_size , T_ok ; mbedtls_ecp_point * T ; ECP_RS_ENTER ( rsm ); /* Is P the base point ? */ #if MBEDTLS_ECP_FIXED_POINT_OPTIM == 1 p_eq_g = ( mbedtls_mpi_cmp_mpi ( & P -> Y , & grp -> G . Y ) == 0 && mbedtls_mpi_cmp_mpi ( & P -> X , & grp -> G . X ) == 0 ); #else p_eq_g = 0 ; #endif /* Pick window size and deduce related sizes */ w = ecp_pick_window_size ( grp , p_eq_g ); T_size = 1U << ( w - 1 ); d = ( grp -> nbits + w - 1 ) / w ; /* Pre-computed table: do we have it already for the base point? */ if ( p_eq_g && grp -> T != NULL ) { /* second pointer to the same table, will be deleted on exit */ T = grp -> T ; T_ok = 1 ; } else #if defined(MBEDTLS_ECP_RESTARTABLE) /* Pre-computed table: do we have one in progress? complete? */ if ( rs_ctx != NULL && rs_ctx -> rsm != NULL && rs_ctx -> rsm -> T != NULL ) { /* transfer ownership of T from rsm to local function */ T = rs_ctx -> rsm -> T ; rs_ctx -> rsm -> T = NULL ; rs_ctx -> rsm -> T_size = 0 ; /* This effectively jumps to the call to mul_comb_after_precomp() */ T_ok = rs_ctx -> rsm -> state >= ecp_rsm_comb_core ; } else #endif /* Allocate table if we didn't have any */ { T = mbedtls_calloc ( T_size , sizeof ( mbedtls_ecp_point ) ); if ( T == NULL ) { ret = MBEDTLS_ERR_ECP_ALLOC_FAILED ; goto cleanup ; } for ( i = 0 ; i < T_size ; i ++ ) mbedtls_ecp_point_init ( & T [ i ] ); T_ok = 0 ; } /* Compute table (or finish computing it) if not done already */ if ( ! T_ok ) { MBEDTLS_MPI_CHK ( ecp_precompute_comb ( grp , T , P , w , d , rs_ctx ) ); if ( p_eq_g ) { /* almost transfer ownership of T to the group, but keep a copy of * the pointer to use for calling the next function more easily */ grp -> T = T ; grp -> T_size = T_size ; } } /* Actual comb multiplication using precomputed points */ MBEDTLS_MPI_CHK ( ecp_mul_comb_after_precomp ( grp , R , m , T , T_size , w , d , f_rng , p_rng , rs_ctx ) ); cleanup : /* does T belong to the group? */ if ( T == grp -> T ) T = NULL ;","title":"ecp_mul_comb\u51fd\u6570\u4ee3\u7801(ecp.c 2001)"},{"location":"tools/mbedtls_ecp_mul_restartable/#ecp_mul_comb","text":"\u692d\u5706\u66f2\u7ebf\u4e0a\u7684\u70b9\u4e58\u6cd5\u8fd0\u7b97\uff0c\u4f7f\u7528\u4e86\u7ec4\u5408\u7b97\u6cd5\uff08Comb method\uff09\u6765\u4f18\u5316\u8ba1\u7b97\u6548\u7387\u3002 \u9996\u5148\uff0c\u51fd\u6570\u58f0\u660e\u4e86\u4e00\u4e9b\u53d8\u91cf\u548c\u6307\u9488\uff0c\u5982\u679c\u5f00\u542f\u4e86restartable\u5219\u8bb0\u5f55\u65ad\u70b9\u3002 \u51fd\u6570\u68c0\u67e5\u70b9 P \u662f\u5426\u4e3a\u57fa\u70b9\uff0c\u5373 P \u662f\u5426\u4e0e\u692d\u5706\u66f2\u7ebf\u7fa4\u7684\u57fa\u70b9 G \u76f8\u7b49\u3002\u5982\u679c MBEDTLS_ECP_FIXED_POINT_OPTIM \u5b9a\u4e49\u4e3a 1\uff0c\u5e76\u4e14 P \u7684\u5750\u6807\u4e0e G \u7684\u5750\u6807\u76f8\u7b49\uff0c\u5219\u5c06 p_eq_g \u8bbe\u7f6e\u4e3a 1\uff1b\u5426\u5219\u8bbe\u7f6e\u4e3a 0\u3002 \u51fd\u6570\u8c03\u7528 ecp_pick_window_size \u6765\u9009\u62e9\u7a97\u53e3\u5927\u5c0f\uff0c\u7a97\u53e3\u5927\u5c0f\u7684\u9009\u62e9\u53d6\u51b3\u4e8e p_eq_g \u7684\u503c\u548c\u692d\u5706\u66f2\u7ebf\u7fa4\u7684\u53c2\u6570\u3002\u7a97\u53e3\u5927\u5c0f\u51b3\u5b9a\u4e86\u9884\u8ba1\u7b97\u8868\u7684\u5927\u5c0f\u3002 \u6839\u636e\u7a97\u53e3\u5927\u5c0f\u8ba1\u7b97\u9884\u8ba1\u7b97\u8868\u7684\u5927\u5c0f\uff0c\u5e76\u8ba1\u7b97 d \u7684\u503c\uff0c d \u8868\u793a\u6807\u91cf\u503c\u7684\u4f4d\u6570\u9664\u4ee5\u7a97\u53e3\u5927\u5c0f\u540e\u7684\u7ed3\u679c\u3002 \u51fd\u6570\u6839\u636e\u662f\u5426\u5df2\u7ecf\u5b58\u5728\u57fa\u70b9\u7684\u9884\u8ba1\u7b97\u8868\u6765\u5224\u65ad\u662f\u5426\u9700\u8981\u8fdb\u884c\u9884\u8ba1\u7b97\u8868\u7684\u751f\u6210\uff1a \u5982\u679c p_eq_g \u4e3a\u771f\u4e14 grp->T \u4e0d\u4e3a\u7a7a\uff0c\u5219\u76f4\u63a5\u4f7f\u7528 grp->T \u4f5c\u4e3a\u9884\u8ba1\u7b97\u8868\uff0c\u5e76\u5c06 T_ok \u8bbe\u7f6e\u4e3a 1\u3002 \u5426\u5219\uff0c\u5982\u679c\u542f\u7528\u4e86\u91cd\u542f\u529f\u80fd\uff0c\u5e76\u4e14\u5b58\u5728\u6b63\u5728\u8fdb\u884c\u7684\u9884\u8ba1\u7b97\u8868\uff0c\u5219\u5c06\u9884\u8ba1\u7b97\u8868\u4ece rs_ctx \u4e2d\u8f6c\u79fb\u5230\u672c\u5730\u53d8\u91cf T \u4e2d\uff0c\u5e76\u5c06 T_ok \u8bbe\u7f6e\u4e3a 1\u3002 \u5426\u5219\uff0c\u5206\u914d T_size \u5927\u5c0f\u7684\u5185\u5b58\u7528\u4e8e\u5b58\u50a8\u9884\u8ba1\u7b97\u8868\uff0c\u5e76\u521d\u59cb\u5316\u9884\u8ba1\u7b97\u8868\u4e2d\u7684\u70b9\u3002 \u5982\u679c\u5185\u5b58\u5206\u914d\u5931\u8d25\uff0c\u5219\u8fd4\u56de MBEDTLS_ERR_ECP_ALLOC_FAILED \u9519\u8bef\u3002 \u5982\u679c\u9884\u8ba1\u7b97\u8868\u4e0d\u5b58\u5728\u6216\u8005\u9700\u8981\u91cd\u65b0\u8ba1\u7b97\uff0c\u8c03\u7528 ecp_precompute_comb \u51fd\u6570\u751f\u6210\u9884\u8ba1\u7b97\u8868\u3002\u8be5\u51fd\u6570\u4f7f\u7528\u7ec4\u5408\u7b97\u6cd5\uff08Comb method\uff09\u6765\u751f\u6210\u9884\u8ba1\u7b97\u8868\uff0c\u63d0\u524d\u8ba1\u7b97\u51fa\u4e00\u7cfb\u5217\u70b9\u7684\u5750\u6807\uff0c\u4ee5\u7528\u4e8e\u540e\u7eed\u7684\u70b9\u4e58\u6cd5\u8fd0\u7b97\u3002\u751f\u6210\u9884\u8ba1\u7b97\u8868\u7684\u8fc7\u7a0b\u53ef\u80fd\u4f1a\u6d89\u53ca\u5230\u91cd\u542f\u529f\u80fd\u3002 \u5982\u679c P \u662f\u57fa\u70b9\uff0c\u5219\u5c06 T \u7684\u6240\u6709\u6743\u8f6c\u79fb\u5230\u7fa4\u7ed3\u6784\u4f53 grp \u4e2d\uff0c\u5e76\u5c06 grp->T \u548c grp->T_size \u8bbe\u7f6e\u4e3a\u76f8\u5e94\u7684\u503c\u3002 \u6700\u540e\uff0c\u8c03\u7528 ecp_mul_comb_after_precomp \u51fd\u6570\u6267\u884c\u57fa\u4e8e\u9884\u8ba1\u7b97\u8868\u7684\u70b9\u4e58\u6cd5\u8fd0\u7b97\u3002\u8be5\u51fd\u6570\u4f7f\u7528\u9884\u8ba1\u7b97\u8868\u4e2d\u7684\u70b9\u8fdb\u884c\u70b9\u4e58\u6cd5\u8fd0\u7b97\uff0c\u53ef\u4ee5\u5927\u5927\u63d0\u9ad8\u8ba1\u7b97\u6548\u7387\u3002\u8fd0\u7b97\u7ed3\u679c\u5b58\u50a8\u5728 R \u4e2d\u3002 \u6e05\u7406\u9636\u6bb5\uff0c\u91ca\u653e\u9884\u8ba1\u7b97\u8868\u7684\u5185\u5b58\u8d44\u6e90\uff0c\u5e76\u6839\u636e T \u662f\u5426\u5c5e\u4e8e\u7fa4\u7ed3\u6784\u4f53 grp \u6765\u786e\u5b9a\u662f\u5426\u5c06 T \u8bbe\u7f6e\u4e3a NULL\u3002 \u5176\u4e2d\u6838\u5fc3\u51fd\u6570\u4e3aecp_mul_comb_after_precomp","title":"ecp_mul_comb\u51fd\u6570\u8bf4\u660e"},{"location":"tools/mbedtls_ecp_mul_restartable/#ecp_mul_comb_after_precompecpc-1903","text":"static int ecp_mul_comb_after_precomp ( const mbedtls_ecp_group * grp , mbedtls_ecp_point * R , const mbedtls_mpi * m , const mbedtls_ecp_point * T , unsigned char T_size , unsigned char w , size_t d , int ( * f_rng )( void * , unsigned char * , size_t ), void * p_rng , mbedtls_ecp_restart_ctx * rs_ctx ) { int ret ; unsigned char parity_trick ; unsigned char k [ COMB_MAX_D + 1 ]; mbedtls_ecp_point * RR = R ; #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> rsm != NULL ) { RR = & rs_ctx -> rsm -> R ; if ( rs_ctx -> rsm -> state == ecp_rsm_final_norm ) goto final_norm ; } #endif MBEDTLS_MPI_CHK ( ecp_comb_recode_scalar ( grp , m , k , d , w , & parity_trick ) ); MBEDTLS_MPI_CHK ( ecp_mul_comb_core ( grp , RR , T , T_size , k , d , f_rng , p_rng , rs_ctx ) ); MBEDTLS_MPI_CHK ( ecp_safe_invert_jac ( grp , RR , parity_trick ) ); #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> rsm != NULL ) rs_ctx -> rsm -> state = ecp_rsm_final_norm ; final_norm : #endif MBEDTLS_ECP_BUDGET ( MBEDTLS_ECP_OPS_INV ); MBEDTLS_MPI_CHK ( ecp_normalize_jac ( grp , RR ) ); #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> rsm != NULL ) MBEDTLS_MPI_CHK ( mbedtls_ecp_copy ( R , RR ) ); #endif cleanup : return ( ret ); }","title":"ecp_mul_comb_after_precomp\u51fd\u6570\u4ee3\u7801\uff08ecp.c 1903\uff09"},{"location":"tools/mbedtls_ecp_mul_restartable/#ecp_mul_comb_after_precomp","text":"\u9996\u5148\uff0c\u51fd\u6570\u58f0\u660e\u4e86\u4e00\u4e9b\u53d8\u91cf\u548c\u6307\u9488\uff0c\u5982\u679c\u5f00\u542f\u4e86restartable\u5219\u8bb0\u5f55\u65ad\u70b9\u3002 \u8c03\u7528ecp_comb_recode_scalar\u51fd\u6570\u5bf9\u6807\u91cf\u503c\u8fdb\u884c\u7f16\u7801\uff0c\u5f97\u5230\u9884\u8ba1\u7b97\u7684\u7a97\u53e3\u8868 \u8c03\u7528ecp_mul_comb_core\u51fd\u6570\u6267\u884c\u70b9\u4e58\u6cd5\u8fd0\u7b97\uff0c\u4f7f\u7528\u9884\u8ba1\u7b97\u7684\u7a97\u53e3\u8868\u548c\u7f16\u7801\u540e\u7684\u6807\u91cf\u503c\u3002 \u8c03\u7528ecp_safe_invert_jac\u51fd\u6570\u5bf9\u7ed3\u679c\u70b9\u8fdb\u884c\u96c5\u53ef\u6bd4\u5750\u6807\u7cfb\u4e0b\u7684\u5b89\u5168\u53cd\u8f6c\uff08inversion\uff09\u64cd\u4f5c\uff0c\u4ee5\u786e\u4fdd\u7ed3\u679c\u7684\u6b63\u786e\u6027\u3002 \u6267\u884cecp_normalize_jac\u51fd\u6570\u5bf9\u7ed3\u679c\u70b9\u8fdb\u884c\u89c4\u8303\u5316\u64cd\u4f5c\uff0c\u5c06\u7ed3\u679c\u70b9\u4ece\u96c5\u53ef\u6bd4\u5750\u6807\u7cfb\u8f6c\u6362\u4e3a\u4eff\u5c04\u5750\u6807\u7cfb\u3002 \u5982\u679c\u542f\u7528\u4e86\u91cd\u542f\u673a\u5236\uff0c\u5c06\u89c4\u8303\u5316\u540e\u7684\u7ed3\u679c\u70b9\u62f7\u8d1d\u5230\u8f93\u51fa\u53c2\u6570R\u4e2d\u3002 \u8fd4\u56de\u6267\u884c\u7ed3\u679c\u3002","title":"ecp_mul_comb_after_precomp\u51fd\u6570\u8bf4\u660e"},{"location":"tools/mbedtls_mpi_fill_random/","text":"mbedtls_mpi_fill_random(bignum.c 2121) \u51fd\u6570\u6d41\u7a0b graph TB Z[mbedtls_ecp_gen_privkey\u51fd\u6570] A[\u8f93\u5165] -->B(\u5b9a\u4e49\u53d8\u91cf,\u68c0\u67e5\u5408\u6cd5\u6027) B --> C(\u5982\u679climb\u6570\u91cf\u4e0d\u5bf9\u5219\u91cd\u65b0\u5206\u914d\u7a7a\u95f4) C --> E(\u8c03\u7528f_rng \u4e00\u822c\u662f\u81ea\u5b9a\u4e49\u7684\u968f\u673a\u6570\u53d1\u751f\u5668) E --> H[\u8f93\u51fa] \u51fd\u6570\u4ee3\u7801 */ int mbedtls_mpi_fill_random ( mbedtls_mpi * X , size_t size , int ( * f_rng )( void * , unsigned char * , size_t ), void * p_rng ) { int ret ; size_t const limbs = CHARS_TO_LIMBS ( size ); size_t const overhead = ( limbs * ciL ) - size ; unsigned char * Xp ; MPI_VALIDATE_RET ( X != NULL ); MPI_VALIDATE_RET ( f_rng != NULL ); /* Ensure that target MPI has exactly the necessary number of limbs */ if ( X -> n != limbs ) { mbedtls_mpi_free ( X ); mbedtls_mpi_init ( X ); MBEDTLS_MPI_CHK ( mbedtls_mpi_grow ( X , limbs ) ); } MBEDTLS_MPI_CHK ( mbedtls_mpi_lset ( X , 0 ) ); Xp = ( unsigned char * ) X -> p ; f_rng ( p_rng , Xp + overhead , size ); mpi_bigendian_to_host ( X -> p , limbs ); cleanup : return ( ret ); } \u51fd\u6570\u8bf4\u660e \u51fd\u6570\u9996\u5148\u5bf9\u8f93\u5165\u53c2\u6570\u8fdb\u884c\u9a8c\u8bc1\uff0c\u786e\u4fdd\u5b83\u4eec\u4e0d\u4e3a NULL\u3002\u7136\u540e\uff0c\u51fd\u6570\u8ba1\u7b97\u51fa\u76ee\u6807\u5927\u6574\u6570\u6240\u9700\u8981\u7684 limbs \u6570\u91cf\uff0c\u5e76\u5206\u914d\u76f8\u5e94\u7684\u5b58\u50a8\u7a7a\u95f4\u3002\u5982\u679c\u76ee\u6807\u5927\u6574\u6570\u7684 limbs \u6570\u91cf\u4e0e\u6240\u9700\u7684\u6570\u91cf\u4e0d\u540c\uff0c\u5219\u5148\u91ca\u653e\u76ee\u6807\u5927\u6574\u6570\u7684\u5b58\u50a8\u7a7a\u95f4\uff0c\u5e76\u91cd\u65b0\u5206\u914d\u6240\u9700\u7684\u5b58\u50a8\u7a7a\u95f4\u3002\u63a5\u7740\uff0c\u51fd\u6570\u5c06\u76ee\u6807\u5927\u6574\u6570\u7684\u503c\u8bbe\u7f6e\u4e3a 0\u3002 \u63a5\u4e0b\u6765\uff0c\u51fd\u6570\u751f\u6210\u4e00\u4e2a\u968f\u673a\u6570\uff0c\u5e76\u5c06\u5176\u586b\u5145\u5230\u76ee\u6807\u5927\u6574\u6570\u4e2d\u3002\u4e3a\u4e86\u9632\u6b62\u586b\u5145\u7684\u968f\u673a\u6570\u6ea2\u51fa\u76ee\u6807\u5927\u6574\u6570\u7684\u4f4d\u6570\uff0c\u51fd\u6570\u9700\u8981\u8ba1\u7b97\u51fa\u586b\u5145\u968f\u673a\u6570\u6240\u9700\u8981\u7684\u5b57\u8282\u6570\uff0c\u4ee5\u53ca\u76ee\u6807\u5927\u6574\u6570\u7684\u5b58\u50a8\u6307\u9488\u3002\u968f\u673a\u6570\u751f\u6210\u5668 f_rng\u8d1f\u8d23\u751f\u6210\u968f\u673a\u6570\uff0c\u800c\u6307\u9488 p_rng \u5219\u7528\u4e8e\u4f20\u9012\u968f\u673a\u6570\u751f\u6210\u5668\u7684\u4e0a\u4e0b\u6587\u4fe1\u606f\u3002","title":"mbedtls_mpi_fill_random"},{"location":"tools/mbedtls_mpi_fill_random/#mbedtls_mpi_fill_randombignumc-2121","text":"","title":"mbedtls_mpi_fill_random(bignum.c 2121)"},{"location":"tools/mbedtls_mpi_fill_random/#_1","text":"graph TB Z[mbedtls_ecp_gen_privkey\u51fd\u6570] A[\u8f93\u5165] -->B(\u5b9a\u4e49\u53d8\u91cf,\u68c0\u67e5\u5408\u6cd5\u6027) B --> C(\u5982\u679climb\u6570\u91cf\u4e0d\u5bf9\u5219\u91cd\u65b0\u5206\u914d\u7a7a\u95f4) C --> E(\u8c03\u7528f_rng \u4e00\u822c\u662f\u81ea\u5b9a\u4e49\u7684\u968f\u673a\u6570\u53d1\u751f\u5668) E --> H[\u8f93\u51fa]","title":"\u51fd\u6570\u6d41\u7a0b"},{"location":"tools/mbedtls_mpi_fill_random/#_2","text":"*/ int mbedtls_mpi_fill_random ( mbedtls_mpi * X , size_t size , int ( * f_rng )( void * , unsigned char * , size_t ), void * p_rng ) { int ret ; size_t const limbs = CHARS_TO_LIMBS ( size ); size_t const overhead = ( limbs * ciL ) - size ; unsigned char * Xp ; MPI_VALIDATE_RET ( X != NULL ); MPI_VALIDATE_RET ( f_rng != NULL ); /* Ensure that target MPI has exactly the necessary number of limbs */ if ( X -> n != limbs ) { mbedtls_mpi_free ( X ); mbedtls_mpi_init ( X ); MBEDTLS_MPI_CHK ( mbedtls_mpi_grow ( X , limbs ) ); } MBEDTLS_MPI_CHK ( mbedtls_mpi_lset ( X , 0 ) ); Xp = ( unsigned char * ) X -> p ; f_rng ( p_rng , Xp + overhead , size ); mpi_bigendian_to_host ( X -> p , limbs ); cleanup : return ( ret ); }","title":"\u51fd\u6570\u4ee3\u7801"},{"location":"tools/mbedtls_mpi_fill_random/#_3","text":"\u51fd\u6570\u9996\u5148\u5bf9\u8f93\u5165\u53c2\u6570\u8fdb\u884c\u9a8c\u8bc1\uff0c\u786e\u4fdd\u5b83\u4eec\u4e0d\u4e3a NULL\u3002\u7136\u540e\uff0c\u51fd\u6570\u8ba1\u7b97\u51fa\u76ee\u6807\u5927\u6574\u6570\u6240\u9700\u8981\u7684 limbs \u6570\u91cf\uff0c\u5e76\u5206\u914d\u76f8\u5e94\u7684\u5b58\u50a8\u7a7a\u95f4\u3002\u5982\u679c\u76ee\u6807\u5927\u6574\u6570\u7684 limbs \u6570\u91cf\u4e0e\u6240\u9700\u7684\u6570\u91cf\u4e0d\u540c\uff0c\u5219\u5148\u91ca\u653e\u76ee\u6807\u5927\u6574\u6570\u7684\u5b58\u50a8\u7a7a\u95f4\uff0c\u5e76\u91cd\u65b0\u5206\u914d\u6240\u9700\u7684\u5b58\u50a8\u7a7a\u95f4\u3002\u63a5\u7740\uff0c\u51fd\u6570\u5c06\u76ee\u6807\u5927\u6574\u6570\u7684\u503c\u8bbe\u7f6e\u4e3a 0\u3002 \u63a5\u4e0b\u6765\uff0c\u51fd\u6570\u751f\u6210\u4e00\u4e2a\u968f\u673a\u6570\uff0c\u5e76\u5c06\u5176\u586b\u5145\u5230\u76ee\u6807\u5927\u6574\u6570\u4e2d\u3002\u4e3a\u4e86\u9632\u6b62\u586b\u5145\u7684\u968f\u673a\u6570\u6ea2\u51fa\u76ee\u6807\u5927\u6574\u6570\u7684\u4f4d\u6570\uff0c\u51fd\u6570\u9700\u8981\u8ba1\u7b97\u51fa\u586b\u5145\u968f\u673a\u6570\u6240\u9700\u8981\u7684\u5b57\u8282\u6570\uff0c\u4ee5\u53ca\u76ee\u6807\u5927\u6574\u6570\u7684\u5b58\u50a8\u6307\u9488\u3002\u968f\u673a\u6570\u751f\u6210\u5668 f_rng\u8d1f\u8d23\u751f\u6210\u968f\u673a\u6570\uff0c\u800c\u6307\u9488 p_rng \u5219\u7528\u4e8e\u4f20\u9012\u968f\u673a\u6570\u751f\u6210\u5668\u7684\u4e0a\u4e0b\u6587\u4fe1\u606f\u3002","title":"\u51fd\u6570\u8bf4\u660e"},{"location":"tools/mpi/","text":"\u5927\u6574\u6570\u8ba1\u7b97\u51fd\u6570 mbedtls_mpi\u5927\u6574\u6570\u7c7b typedef struct mbedtls_mpi { int s ; /*!< integer sign */ size_t n ; /*!< total # of limbs */ mbedtls_mpi_uint * p ; /*!< pointer to limbs */ } mbedtls_mpi ; \u5927\u6574\u6570\u7c7b\u4e2dX->s\u6307\u5927\u6570\u7684\u6b63\u8d1f\uff0cX->\u6307\u6570\u4f4d\u603b\u6570\uff0cX->p[n]\u6307\u5411\u6bcf\u4e00\u4f4d\uff0c\u5927\u5c0f\u4e3a32\u4f4d\u621664\u4f4d\u6570\u3002\u5927\u6574\u6570\u88ab\u4fdd\u5b58\u4e3a\u6570\u7ec4\u7684\u5f62\u5f0f\uff0c\u4f8b\uff1a A -> s = -1 , A -> n = 2 A -> [ 0 ] = 65535 A -> [ 1 ] = 1 mbedtls_mpi_mod_mpi \u53d6\u6a21\u8fd0\u7b97\uff08bignum.c 1684\uff09 \u8ba1\u7b97R = A mod B int mbedtls_mpi_mod_mpi ( mbedtls_mpi * R , const mbedtls_mpi * A , const mbedtls_mpi * B ) { int ret ; MPI_VALIDATE_RET ( R != NULL ); MPI_VALIDATE_RET ( A != NULL ); MPI_VALIDATE_RET ( B != NULL ); if ( mbedtls_mpi_cmp_int ( B , 0 ) < 0 ) return ( MBEDTLS_ERR_MPI_NEGATIVE_VALUE ); MBEDTLS_MPI_CHK ( mbedtls_mpi_div_mpi ( NULL , R , A , B ) ); while ( mbedtls_mpi_cmp_int ( R , 0 ) < 0 ) MBEDTLS_MPI_CHK ( mbedtls_mpi_add_mpi ( R , R , B ) ); while ( mbedtls_mpi_cmp_mpi ( R , B ) >= 0 ) MBEDTLS_MPI_CHK ( mbedtls_mpi_sub_mpi ( R , R , B ) ); cleanup : return ( ret ); } mbedtls_mpi_mul_mpi \u4e58\u6cd5\u8fd0\u7b97\uff08bignum.c 1393\uff09 \u8ba1\u7b97X=A * B int mbedtls_mpi_mul_mpi ( mbedtls_mpi * X , const mbedtls_mpi * A , const mbedtls_mpi * B ) { int ret ; size_t i , j ; mbedtls_mpi TA , TB ; MPI_VALIDATE_RET ( X != NULL ); MPI_VALIDATE_RET ( A != NULL ); MPI_VALIDATE_RET ( B != NULL ); mbedtls_mpi_init ( & TA ); mbedtls_mpi_init ( & TB ); if ( X == A ) { MBEDTLS_MPI_CHK ( mbedtls_mpi_copy ( & TA , A ) ); A = & TA ; } if ( X == B ) { MBEDTLS_MPI_CHK ( mbedtls_mpi_copy ( & TB , B ) ); B = & TB ; } for ( i = A -> n ; i > 0 ; i -- ) if ( A -> p [ i - 1 ] != 0 ) break ; for ( j = B -> n ; j > 0 ; j -- ) if ( B -> p [ j - 1 ] != 0 ) break ; MBEDTLS_MPI_CHK ( mbedtls_mpi_grow ( X , i + j ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_lset ( X , 0 ) ); for ( ; j > 0 ; j -- ) mpi_mul_hlp ( i , A -> p , X -> p + j - 1 , B -> p [ j - 1 ] ); X -> s = A -> s * B -> s ; cleanup : mbedtls_mpi_free ( & TB ); mbedtls_mpi_free ( & TA ); return ( ret ); } mbedtls_mpi_add_mpi \u52a0\u6cd5\u8fd0\u7b97\uff08bignum.c 1089\uff09 int mbedtls_mpi_add_mpi ( mbedtls_mpi * X , const mbedtls_mpi * A , const mbedtls_mpi * B ) { int ret , s ; MPI_VALIDATE_RET ( X != NULL ); MPI_VALIDATE_RET ( A != NULL ); MPI_VALIDATE_RET ( B != NULL ); s = A -> s ; if ( A -> s * B -> s < 0 ) { if ( mbedtls_mpi_cmp_abs ( A , B ) >= 0 ) { MBEDTLS_MPI_CHK ( mbedtls_mpi_sub_abs ( X , A , B ) ); X -> s = s ; } else { MBEDTLS_MPI_CHK ( mbedtls_mpi_sub_abs ( X , B , A ) ); X -> s = - s ; } } else { MBEDTLS_MPI_CHK ( mbedtls_mpi_add_abs ( X , A , B ) ); X -> s = s ; } cleanup : return ( ret ); } mbedtls_mpi_inv_mod \u6a21\u9006\u8fd0\u7b97\uff08bignum.c 2154\uff09 x^-1 mod N int mbedtls_mpi_inv_mod ( mbedtls_mpi * X , const mbedtls_mpi * A , const mbedtls_mpi * N ) { int ret ; mbedtls_mpi G , TA , TU , U1 , U2 , TB , TV , V1 , V2 ; MPI_VALIDATE_RET ( X != NULL ); MPI_VALIDATE_RET ( A != NULL ); MPI_VALIDATE_RET ( N != NULL ); if ( mbedtls_mpi_cmp_int ( N , 1 ) <= 0 ) return ( MBEDTLS_ERR_MPI_BAD_INPUT_DATA ); mbedtls_mpi_init ( & TA ); mbedtls_mpi_init ( & TU ); mbedtls_mpi_init ( & U1 ); mbedtls_mpi_init ( & U2 ); mbedtls_mpi_init ( & G ); mbedtls_mpi_init ( & TB ); mbedtls_mpi_init ( & TV ); mbedtls_mpi_init ( & V1 ); mbedtls_mpi_init ( & V2 ); MBEDTLS_MPI_CHK ( mbedtls_mpi_gcd ( & G , A , N ) ); if ( mbedtls_mpi_cmp_int ( & G , 1 ) != 0 ) { ret = MBEDTLS_ERR_MPI_NOT_ACCEPTABLE ; goto cleanup ; } MBEDTLS_MPI_CHK ( mbedtls_mpi_mod_mpi ( & TA , A , N ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_copy ( & TU , & TA ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_copy ( & TB , N ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_copy ( & TV , N ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_lset ( & U1 , 1 ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_lset ( & U2 , 0 ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_lset ( & V1 , 0 ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_lset ( & V2 , 1 ) ); do { while ( ( TU . p [ 0 ] & 1 ) == 0 ) { MBEDTLS_MPI_CHK ( mbedtls_mpi_shift_r ( & TU , 1 ) ); if ( ( U1 . p [ 0 ] & 1 ) != 0 || ( U2 . p [ 0 ] & 1 ) != 0 ) { MBEDTLS_MPI_CHK ( mbedtls_mpi_add_mpi ( & U1 , & U1 , & TB ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_sub_mpi ( & U2 , & U2 , & TA ) ); } MBEDTLS_MPI_CHK ( mbedtls_mpi_shift_r ( & U1 , 1 ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_shift_r ( & U2 , 1 ) ); } while ( ( TV . p [ 0 ] & 1 ) == 0 ) { MBEDTLS_MPI_CHK ( mbedtls_mpi_shift_r ( & TV , 1 ) ); if ( ( V1 . p [ 0 ] & 1 ) != 0 || ( V2 . p [ 0 ] & 1 ) != 0 ) { MBEDTLS_MPI_CHK ( mbedtls_mpi_add_mpi ( & V1 , & V1 , & TB ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_sub_mpi ( & V2 , & V2 , & TA ) ); } MBEDTLS_MPI_CHK ( mbedtls_mpi_shift_r ( & V1 , 1 ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_shift_r ( & V2 , 1 ) ); } if ( mbedtls_mpi_cmp_mpi ( & TU , & TV ) >= 0 ) { MBEDTLS_MPI_CHK ( mbedtls_mpi_sub_mpi ( & TU , & TU , & TV ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_sub_mpi ( & U1 , & U1 , & V1 ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_sub_mpi ( & U2 , & U2 , & V2 ) ); } else { MBEDTLS_MPI_CHK ( mbedtls_mpi_sub_mpi ( & TV , & TV , & TU ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_sub_mpi ( & V1 , & V1 , & U1 ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_sub_mpi ( & V2 , & V2 , & U2 ) ); } } while ( mbedtls_mpi_cmp_int ( & TU , 0 ) != 0 ); while ( mbedtls_mpi_cmp_int ( & V1 , 0 ) < 0 ) MBEDTLS_MPI_CHK ( mbedtls_mpi_add_mpi ( & V1 , & V1 , N ) ); while ( mbedtls_mpi_cmp_mpi ( & V1 , N ) >= 0 ) MBEDTLS_MPI_CHK ( mbedtls_mpi_sub_mpi ( & V1 , & V1 , N ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_copy ( X , & V1 ) ); cleanup : mbedtls_mpi_free ( & TA ); mbedtls_mpi_free ( & TU ); mbedtls_mpi_free ( & U1 ); mbedtls_mpi_free ( & U2 ); mbedtls_mpi_free ( & G ); mbedtls_mpi_free ( & TB ); mbedtls_mpi_free ( & TV ); mbedtls_mpi_free ( & V1 ); mbedtls_mpi_free ( & V2 ); return ( ret ); } mbedtls_mpi_cmp_mpi \uff08bignum.c 1037\uff09 \u6bd4\u8f83\u5927\u5c0f\uff0c\u5927\u6570\u7ed3\u6784\u4f53\u5b58\u653e\u4e86\u6570\u4f4dn\uff0c\u56e0\u6b64\u9996\u5148\u6bd4\u8f83\u4e24\u8005n\u7684\u5927\u5c0f int mbedtls_mpi_cmp_mpi ( const mbedtls_mpi * X , const mbedtls_mpi * Y ) { size_t i , j ; MPI_VALIDATE_RET ( X != NULL ); MPI_VALIDATE_RET ( Y != NULL ); for ( i = X -> n ; i > 0 ; i -- ) if ( X -> p [ i - 1 ] != 0 ) break ; for ( j = Y -> n ; j > 0 ; j -- ) if ( Y -> p [ j - 1 ] != 0 ) break ; if ( i == 0 && j == 0 ) return ( 0 ); if ( i > j ) return ( X -> s ); if ( j > i ) return ( - Y -> s ); if ( X -> s > 0 && Y -> s < 0 ) return ( 1 ); if ( Y -> s > 0 && X -> s < 0 ) return ( -1 ); for ( ; i > 0 ; i -- ) { if ( X -> p [ i - 1 ] > Y -> p [ i - 1 ] ) return ( X -> s ); if ( X -> p [ i - 1 ] < Y -> p [ i - 1 ] ) return ( - X -> s ); } return ( 0 ); }","title":"\u5927\u6574\u6570\u8ba1\u7b97\u51fd\u6570"},{"location":"tools/mpi/#_1","text":"","title":"\u5927\u6574\u6570\u8ba1\u7b97\u51fd\u6570"},{"location":"tools/mpi/#mbedtls_mpi","text":"typedef struct mbedtls_mpi { int s ; /*!< integer sign */ size_t n ; /*!< total # of limbs */ mbedtls_mpi_uint * p ; /*!< pointer to limbs */ } mbedtls_mpi ; \u5927\u6574\u6570\u7c7b\u4e2dX->s\u6307\u5927\u6570\u7684\u6b63\u8d1f\uff0cX->\u6307\u6570\u4f4d\u603b\u6570\uff0cX->p[n]\u6307\u5411\u6bcf\u4e00\u4f4d\uff0c\u5927\u5c0f\u4e3a32\u4f4d\u621664\u4f4d\u6570\u3002\u5927\u6574\u6570\u88ab\u4fdd\u5b58\u4e3a\u6570\u7ec4\u7684\u5f62\u5f0f\uff0c\u4f8b\uff1a A -> s = -1 , A -> n = 2 A -> [ 0 ] = 65535 A -> [ 1 ] = 1","title":"mbedtls_mpi\u5927\u6574\u6570\u7c7b"},{"location":"tools/mpi/#mbedtls_mpi_mod_mpi-bignumc-1684","text":"\u8ba1\u7b97R = A mod B int mbedtls_mpi_mod_mpi ( mbedtls_mpi * R , const mbedtls_mpi * A , const mbedtls_mpi * B ) { int ret ; MPI_VALIDATE_RET ( R != NULL ); MPI_VALIDATE_RET ( A != NULL ); MPI_VALIDATE_RET ( B != NULL ); if ( mbedtls_mpi_cmp_int ( B , 0 ) < 0 ) return ( MBEDTLS_ERR_MPI_NEGATIVE_VALUE ); MBEDTLS_MPI_CHK ( mbedtls_mpi_div_mpi ( NULL , R , A , B ) ); while ( mbedtls_mpi_cmp_int ( R , 0 ) < 0 ) MBEDTLS_MPI_CHK ( mbedtls_mpi_add_mpi ( R , R , B ) ); while ( mbedtls_mpi_cmp_mpi ( R , B ) >= 0 ) MBEDTLS_MPI_CHK ( mbedtls_mpi_sub_mpi ( R , R , B ) ); cleanup : return ( ret ); }","title":"mbedtls_mpi_mod_mpi \u53d6\u6a21\u8fd0\u7b97\uff08bignum.c 1684\uff09"},{"location":"tools/mpi/#mbedtls_mpi_mul_mpi-bignumc-1393","text":"\u8ba1\u7b97X=A * B int mbedtls_mpi_mul_mpi ( mbedtls_mpi * X , const mbedtls_mpi * A , const mbedtls_mpi * B ) { int ret ; size_t i , j ; mbedtls_mpi TA , TB ; MPI_VALIDATE_RET ( X != NULL ); MPI_VALIDATE_RET ( A != NULL ); MPI_VALIDATE_RET ( B != NULL ); mbedtls_mpi_init ( & TA ); mbedtls_mpi_init ( & TB ); if ( X == A ) { MBEDTLS_MPI_CHK ( mbedtls_mpi_copy ( & TA , A ) ); A = & TA ; } if ( X == B ) { MBEDTLS_MPI_CHK ( mbedtls_mpi_copy ( & TB , B ) ); B = & TB ; } for ( i = A -> n ; i > 0 ; i -- ) if ( A -> p [ i - 1 ] != 0 ) break ; for ( j = B -> n ; j > 0 ; j -- ) if ( B -> p [ j - 1 ] != 0 ) break ; MBEDTLS_MPI_CHK ( mbedtls_mpi_grow ( X , i + j ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_lset ( X , 0 ) ); for ( ; j > 0 ; j -- ) mpi_mul_hlp ( i , A -> p , X -> p + j - 1 , B -> p [ j - 1 ] ); X -> s = A -> s * B -> s ; cleanup : mbedtls_mpi_free ( & TB ); mbedtls_mpi_free ( & TA ); return ( ret ); }","title":"mbedtls_mpi_mul_mpi \u4e58\u6cd5\u8fd0\u7b97\uff08bignum.c 1393\uff09"},{"location":"tools/mpi/#mbedtls_mpi_add_mpi-bignumc-1089","text":"int mbedtls_mpi_add_mpi ( mbedtls_mpi * X , const mbedtls_mpi * A , const mbedtls_mpi * B ) { int ret , s ; MPI_VALIDATE_RET ( X != NULL ); MPI_VALIDATE_RET ( A != NULL ); MPI_VALIDATE_RET ( B != NULL ); s = A -> s ; if ( A -> s * B -> s < 0 ) { if ( mbedtls_mpi_cmp_abs ( A , B ) >= 0 ) { MBEDTLS_MPI_CHK ( mbedtls_mpi_sub_abs ( X , A , B ) ); X -> s = s ; } else { MBEDTLS_MPI_CHK ( mbedtls_mpi_sub_abs ( X , B , A ) ); X -> s = - s ; } } else { MBEDTLS_MPI_CHK ( mbedtls_mpi_add_abs ( X , A , B ) ); X -> s = s ; } cleanup : return ( ret ); }","title":"mbedtls_mpi_add_mpi \u52a0\u6cd5\u8fd0\u7b97\uff08bignum.c 1089\uff09"},{"location":"tools/mpi/#mbedtls_mpi_inv_mod-bignumc-2154","text":"x^-1 mod N int mbedtls_mpi_inv_mod ( mbedtls_mpi * X , const mbedtls_mpi * A , const mbedtls_mpi * N ) { int ret ; mbedtls_mpi G , TA , TU , U1 , U2 , TB , TV , V1 , V2 ; MPI_VALIDATE_RET ( X != NULL ); MPI_VALIDATE_RET ( A != NULL ); MPI_VALIDATE_RET ( N != NULL ); if ( mbedtls_mpi_cmp_int ( N , 1 ) <= 0 ) return ( MBEDTLS_ERR_MPI_BAD_INPUT_DATA ); mbedtls_mpi_init ( & TA ); mbedtls_mpi_init ( & TU ); mbedtls_mpi_init ( & U1 ); mbedtls_mpi_init ( & U2 ); mbedtls_mpi_init ( & G ); mbedtls_mpi_init ( & TB ); mbedtls_mpi_init ( & TV ); mbedtls_mpi_init ( & V1 ); mbedtls_mpi_init ( & V2 ); MBEDTLS_MPI_CHK ( mbedtls_mpi_gcd ( & G , A , N ) ); if ( mbedtls_mpi_cmp_int ( & G , 1 ) != 0 ) { ret = MBEDTLS_ERR_MPI_NOT_ACCEPTABLE ; goto cleanup ; } MBEDTLS_MPI_CHK ( mbedtls_mpi_mod_mpi ( & TA , A , N ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_copy ( & TU , & TA ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_copy ( & TB , N ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_copy ( & TV , N ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_lset ( & U1 , 1 ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_lset ( & U2 , 0 ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_lset ( & V1 , 0 ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_lset ( & V2 , 1 ) ); do { while ( ( TU . p [ 0 ] & 1 ) == 0 ) { MBEDTLS_MPI_CHK ( mbedtls_mpi_shift_r ( & TU , 1 ) ); if ( ( U1 . p [ 0 ] & 1 ) != 0 || ( U2 . p [ 0 ] & 1 ) != 0 ) { MBEDTLS_MPI_CHK ( mbedtls_mpi_add_mpi ( & U1 , & U1 , & TB ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_sub_mpi ( & U2 , & U2 , & TA ) ); } MBEDTLS_MPI_CHK ( mbedtls_mpi_shift_r ( & U1 , 1 ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_shift_r ( & U2 , 1 ) ); } while ( ( TV . p [ 0 ] & 1 ) == 0 ) { MBEDTLS_MPI_CHK ( mbedtls_mpi_shift_r ( & TV , 1 ) ); if ( ( V1 . p [ 0 ] & 1 ) != 0 || ( V2 . p [ 0 ] & 1 ) != 0 ) { MBEDTLS_MPI_CHK ( mbedtls_mpi_add_mpi ( & V1 , & V1 , & TB ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_sub_mpi ( & V2 , & V2 , & TA ) ); } MBEDTLS_MPI_CHK ( mbedtls_mpi_shift_r ( & V1 , 1 ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_shift_r ( & V2 , 1 ) ); } if ( mbedtls_mpi_cmp_mpi ( & TU , & TV ) >= 0 ) { MBEDTLS_MPI_CHK ( mbedtls_mpi_sub_mpi ( & TU , & TU , & TV ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_sub_mpi ( & U1 , & U1 , & V1 ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_sub_mpi ( & U2 , & U2 , & V2 ) ); } else { MBEDTLS_MPI_CHK ( mbedtls_mpi_sub_mpi ( & TV , & TV , & TU ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_sub_mpi ( & V1 , & V1 , & U1 ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_sub_mpi ( & V2 , & V2 , & U2 ) ); } } while ( mbedtls_mpi_cmp_int ( & TU , 0 ) != 0 ); while ( mbedtls_mpi_cmp_int ( & V1 , 0 ) < 0 ) MBEDTLS_MPI_CHK ( mbedtls_mpi_add_mpi ( & V1 , & V1 , N ) ); while ( mbedtls_mpi_cmp_mpi ( & V1 , N ) >= 0 ) MBEDTLS_MPI_CHK ( mbedtls_mpi_sub_mpi ( & V1 , & V1 , N ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_copy ( X , & V1 ) ); cleanup : mbedtls_mpi_free ( & TA ); mbedtls_mpi_free ( & TU ); mbedtls_mpi_free ( & U1 ); mbedtls_mpi_free ( & U2 ); mbedtls_mpi_free ( & G ); mbedtls_mpi_free ( & TB ); mbedtls_mpi_free ( & TV ); mbedtls_mpi_free ( & V1 ); mbedtls_mpi_free ( & V2 ); return ( ret ); }","title":"mbedtls_mpi_inv_mod \u6a21\u9006\u8fd0\u7b97\uff08bignum.c 2154\uff09"},{"location":"tools/mpi/#mbedtls_mpi_cmp_mpi-bignumc-1037","text":"\u6bd4\u8f83\u5927\u5c0f\uff0c\u5927\u6570\u7ed3\u6784\u4f53\u5b58\u653e\u4e86\u6570\u4f4dn\uff0c\u56e0\u6b64\u9996\u5148\u6bd4\u8f83\u4e24\u8005n\u7684\u5927\u5c0f int mbedtls_mpi_cmp_mpi ( const mbedtls_mpi * X , const mbedtls_mpi * Y ) { size_t i , j ; MPI_VALIDATE_RET ( X != NULL ); MPI_VALIDATE_RET ( Y != NULL ); for ( i = X -> n ; i > 0 ; i -- ) if ( X -> p [ i - 1 ] != 0 ) break ; for ( j = Y -> n ; j > 0 ; j -- ) if ( Y -> p [ j - 1 ] != 0 ) break ; if ( i == 0 && j == 0 ) return ( 0 ); if ( i > j ) return ( X -> s ); if ( j > i ) return ( - Y -> s ); if ( X -> s > 0 && Y -> s < 0 ) return ( 1 ); if ( Y -> s > 0 && X -> s < 0 ) return ( -1 ); for ( ; i > 0 ; i -- ) { if ( X -> p [ i - 1 ] > Y -> p [ i - 1 ] ) return ( X -> s ); if ( X -> p [ i - 1 ] < Y -> p [ i - 1 ] ) return ( - X -> s ); } return ( 0 ); }","title":"mbedtls_mpi_cmp_mpi \uff08bignum.c 1037\uff09"},{"location":"tools/muladd/","text":"mbedtls_ecp_muladd_restartable\uff08ecp.c 2487\uff09 \u51fd\u6570\u4ee3\u7801 int mbedtls_ecp_muladd_restartable ( mbedtls_ecp_group * grp , mbedtls_ecp_point * R , const mbedtls_mpi * m , const mbedtls_ecp_point * P , const mbedtls_mpi * n , const mbedtls_ecp_point * Q , mbedtls_ecp_restart_ctx * rs_ctx ) { int ret ; mbedtls_ecp_point mP ; mbedtls_ecp_point * pmP = & mP ; mbedtls_ecp_point * pR = R ; #if defined(MBEDTLS_ECP_INTERNAL_ALT) char is_grp_capable = 0 ; #endif ECP_VALIDATE_RET ( grp != NULL ); ECP_VALIDATE_RET ( R != NULL ); ECP_VALIDATE_RET ( m != NULL ); ECP_VALIDATE_RET ( P != NULL ); ECP_VALIDATE_RET ( n != NULL ); ECP_VALIDATE_RET ( Q != NULL ); if ( ecp_get_type ( grp ) != ECP_TYPE_SHORT_WEIERSTRASS ) return ( MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE ); mbedtls_ecp_point_init ( & mP ); ECP_RS_ENTER ( ma ); #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> ma != NULL ) { /* redirect intermediate results to restart context */ pmP = & rs_ctx -> ma -> mP ; pR = & rs_ctx -> ma -> R ; /* jump to next operation */ if ( rs_ctx -> ma -> state == ecp_rsma_mul2 ) goto mul2 ; if ( rs_ctx -> ma -> state == ecp_rsma_add ) goto add ; if ( rs_ctx -> ma -> state == ecp_rsma_norm ) goto norm ; } #endif /* MBEDTLS_ECP_RESTARTABLE */ MBEDTLS_MPI_CHK ( mbedtls_ecp_mul_shortcuts ( grp , pmP , m , P , rs_ctx ) ); #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> ma != NULL ) rs_ctx -> ma -> state = ecp_rsma_mul2 ; mul2 : #endif MBEDTLS_MPI_CHK ( mbedtls_ecp_mul_shortcuts ( grp , pR , n , Q , rs_ctx ) ); #if defined(MBEDTLS_ECP_INTERNAL_ALT) if ( ( is_grp_capable = mbedtls_internal_ecp_grp_capable ( grp ) ) ) MBEDTLS_MPI_CHK ( mbedtls_internal_ecp_init ( grp ) ); #endif /* MBEDTLS_ECP_INTERNAL_ALT */ #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> ma != NULL ) rs_ctx -> ma -> state = ecp_rsma_add ; add : #endif MBEDTLS_ECP_BUDGET ( MBEDTLS_ECP_OPS_ADD ); MBEDTLS_MPI_CHK ( ecp_add_mixed ( grp , pR , pmP , pR ) ); #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> ma != NULL ) rs_ctx -> ma -> state = ecp_rsma_norm ; norm : #endif MBEDTLS_ECP_BUDGET ( MBEDTLS_ECP_OPS_INV ); MBEDTLS_MPI_CHK ( ecp_normalize_jac ( grp , pR ) ); #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> ma != NULL ) MBEDTLS_MPI_CHK ( mbedtls_ecp_copy ( R , pR ) ); #endif cleanup : #if defined(MBEDTLS_ECP_INTERNAL_ALT) if ( is_grp_capable ) mbedtls_internal_ecp_free ( grp ); #endif /* MBEDTLS_ECP_INTERNAL_ALT */ mbedtls_ecp_point_free ( & mP ); ECP_RS_LEAVE ( ma ); return ( ret ); } \u51fd\u6570\u8bf4\u660e \u8c03\u7528mbedtls_ecp_mul_shortcuts\u51fd\u6570\u5b8c\u6210\u4e24\u6b21\u4e58\u6cd5\uff0c\u540e\u4f7f\u7528ecp_add_mixed\u5b9e\u73b0\u52a0\u6cd5 mbedtls_ecp_mul_shortcuts\u51fd\u6570\u5185\u8c03\u7528\u7684\u662f mbedtls_ecp_mul_restartable\u51fd\u6570 ecp_add_mixed\u51fd\u6570\u91c7\u7528\u6df7\u5408\u4eff\u5c04-Jacobian\u5750\u6807\u7cfb\u8868\u793a\u70b9\u8ba1\u7b97\u692d\u5706\u66f2\u7ebf\u4e0a\u7684\u52a0\u6cd5 ecp_add_mixed\uff08ecp.c 1357\uff09\u51fd\u6570\u4ee3\u7801 static int ecp_add_mixed ( const mbedtls_ecp_group * grp , mbedtls_ecp_point * R , const mbedtls_ecp_point * P , const mbedtls_ecp_point * Q ) { int ret ; mbedtls_mpi T1 , T2 , T3 , T4 , X , Y , Z ; #if defined(MBEDTLS_SELF_TEST) add_count ++ ; #endif #if defined(MBEDTLS_ECP_ADD_MIXED_ALT) if ( mbedtls_internal_ecp_grp_capable ( grp ) ) return ( mbedtls_internal_ecp_add_mixed ( grp , R , P , Q ) ); #endif /* MBEDTLS_ECP_ADD_MIXED_ALT */ /* * Trivial cases: P == 0 or Q == 0 (case 1) */ if ( mbedtls_mpi_cmp_int ( & P -> Z , 0 ) == 0 ) return ( mbedtls_ecp_copy ( R , Q ) ); if ( Q -> Z . p != NULL && mbedtls_mpi_cmp_int ( & Q -> Z , 0 ) == 0 ) return ( mbedtls_ecp_copy ( R , P ) ); /* * Make sure Q coordinates are normalized */ if ( Q -> Z . p != NULL && mbedtls_mpi_cmp_int ( & Q -> Z , 1 ) != 0 ) return ( MBEDTLS_ERR_ECP_BAD_INPUT_DATA ); mbedtls_mpi_init ( & T1 ); mbedtls_mpi_init ( & T2 ); mbedtls_mpi_init ( & T3 ); mbedtls_mpi_init ( & T4 ); mbedtls_mpi_init ( & X ); mbedtls_mpi_init ( & Y ); mbedtls_mpi_init ( & Z ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( & T1 , & P -> Z , & P -> Z ) ); MOD_MUL ( T1 ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( & T2 , & T1 , & P -> Z ) ); MOD_MUL ( T2 ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( & T1 , & T1 , & Q -> X ) ); MOD_MUL ( T1 ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( & T2 , & T2 , & Q -> Y ) ); MOD_MUL ( T2 ); MBEDTLS_MPI_CHK ( mbedtls_mpi_sub_mpi ( & T1 , & T1 , & P -> X ) ); MOD_SUB ( T1 ); MBEDTLS_MPI_CHK ( mbedtls_mpi_sub_mpi ( & T2 , & T2 , & P -> Y ) ); MOD_SUB ( T2 ); /* Special cases (2) and (3) */ if ( mbedtls_mpi_cmp_int ( & T1 , 0 ) == 0 ) { if ( mbedtls_mpi_cmp_int ( & T2 , 0 ) == 0 ) { ret = ecp_double_jac ( grp , R , P ); goto cleanup ; } else { ret = mbedtls_ecp_set_zero ( R ); goto cleanup ; } } MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( & Z , & P -> Z , & T1 ) ); MOD_MUL ( Z ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( & T3 , & T1 , & T1 ) ); MOD_MUL ( T3 ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( & T4 , & T3 , & T1 ) ); MOD_MUL ( T4 ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( & T3 , & T3 , & P -> X ) ); MOD_MUL ( T3 ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_int ( & T1 , & T3 , 2 ) ); MOD_ADD ( T1 ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( & X , & T2 , & T2 ) ); MOD_MUL ( X ); MBEDTLS_MPI_CHK ( mbedtls_mpi_sub_mpi ( & X , & X , & T1 ) ); MOD_SUB ( X ); MBEDTLS_MPI_CHK ( mbedtls_mpi_sub_mpi ( & X , & X , & T4 ) ); MOD_SUB ( X ); MBEDTLS_MPI_CHK ( mbedtls_mpi_sub_mpi ( & T3 , & T3 , & X ) ); MOD_SUB ( T3 ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( & T3 , & T3 , & T2 ) ); MOD_MUL ( T3 ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( & T4 , & T4 , & P -> Y ) ); MOD_MUL ( T4 ); MBEDTLS_MPI_CHK ( mbedtls_mpi_sub_mpi ( & Y , & T3 , & T4 ) ); MOD_SUB ( Y ); MBEDTLS_MPI_CHK ( mbedtls_mpi_copy ( & R -> X , & X ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_copy ( & R -> Y , & Y ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_copy ( & R -> Z , & Z ) ); cleanup : mbedtls_mpi_free ( & T1 ); mbedtls_mpi_free ( & T2 ); mbedtls_mpi_free ( & T3 ); mbedtls_mpi_free ( & T4 ); mbedtls_mpi_free ( & X ); mbedtls_mpi_free ( & Y ); mbedtls_mpi_free ( & Z ); return ( ret ); }","title":"mbedtls_ecp_muladd_restartable"},{"location":"tools/muladd/#mbedtls_ecp_muladd_restartableecpc-2487","text":"","title":"mbedtls_ecp_muladd_restartable\uff08ecp.c 2487\uff09"},{"location":"tools/muladd/#_1","text":"int mbedtls_ecp_muladd_restartable ( mbedtls_ecp_group * grp , mbedtls_ecp_point * R , const mbedtls_mpi * m , const mbedtls_ecp_point * P , const mbedtls_mpi * n , const mbedtls_ecp_point * Q , mbedtls_ecp_restart_ctx * rs_ctx ) { int ret ; mbedtls_ecp_point mP ; mbedtls_ecp_point * pmP = & mP ; mbedtls_ecp_point * pR = R ; #if defined(MBEDTLS_ECP_INTERNAL_ALT) char is_grp_capable = 0 ; #endif ECP_VALIDATE_RET ( grp != NULL ); ECP_VALIDATE_RET ( R != NULL ); ECP_VALIDATE_RET ( m != NULL ); ECP_VALIDATE_RET ( P != NULL ); ECP_VALIDATE_RET ( n != NULL ); ECP_VALIDATE_RET ( Q != NULL ); if ( ecp_get_type ( grp ) != ECP_TYPE_SHORT_WEIERSTRASS ) return ( MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE ); mbedtls_ecp_point_init ( & mP ); ECP_RS_ENTER ( ma ); #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> ma != NULL ) { /* redirect intermediate results to restart context */ pmP = & rs_ctx -> ma -> mP ; pR = & rs_ctx -> ma -> R ; /* jump to next operation */ if ( rs_ctx -> ma -> state == ecp_rsma_mul2 ) goto mul2 ; if ( rs_ctx -> ma -> state == ecp_rsma_add ) goto add ; if ( rs_ctx -> ma -> state == ecp_rsma_norm ) goto norm ; } #endif /* MBEDTLS_ECP_RESTARTABLE */ MBEDTLS_MPI_CHK ( mbedtls_ecp_mul_shortcuts ( grp , pmP , m , P , rs_ctx ) ); #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> ma != NULL ) rs_ctx -> ma -> state = ecp_rsma_mul2 ; mul2 : #endif MBEDTLS_MPI_CHK ( mbedtls_ecp_mul_shortcuts ( grp , pR , n , Q , rs_ctx ) ); #if defined(MBEDTLS_ECP_INTERNAL_ALT) if ( ( is_grp_capable = mbedtls_internal_ecp_grp_capable ( grp ) ) ) MBEDTLS_MPI_CHK ( mbedtls_internal_ecp_init ( grp ) ); #endif /* MBEDTLS_ECP_INTERNAL_ALT */ #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> ma != NULL ) rs_ctx -> ma -> state = ecp_rsma_add ; add : #endif MBEDTLS_ECP_BUDGET ( MBEDTLS_ECP_OPS_ADD ); MBEDTLS_MPI_CHK ( ecp_add_mixed ( grp , pR , pmP , pR ) ); #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> ma != NULL ) rs_ctx -> ma -> state = ecp_rsma_norm ; norm : #endif MBEDTLS_ECP_BUDGET ( MBEDTLS_ECP_OPS_INV ); MBEDTLS_MPI_CHK ( ecp_normalize_jac ( grp , pR ) ); #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> ma != NULL ) MBEDTLS_MPI_CHK ( mbedtls_ecp_copy ( R , pR ) ); #endif cleanup : #if defined(MBEDTLS_ECP_INTERNAL_ALT) if ( is_grp_capable ) mbedtls_internal_ecp_free ( grp ); #endif /* MBEDTLS_ECP_INTERNAL_ALT */ mbedtls_ecp_point_free ( & mP ); ECP_RS_LEAVE ( ma ); return ( ret ); }","title":"\u51fd\u6570\u4ee3\u7801"},{"location":"tools/muladd/#_2","text":"\u8c03\u7528mbedtls_ecp_mul_shortcuts\u51fd\u6570\u5b8c\u6210\u4e24\u6b21\u4e58\u6cd5\uff0c\u540e\u4f7f\u7528ecp_add_mixed\u5b9e\u73b0\u52a0\u6cd5 mbedtls_ecp_mul_shortcuts\u51fd\u6570\u5185\u8c03\u7528\u7684\u662f mbedtls_ecp_mul_restartable\u51fd\u6570 ecp_add_mixed\u51fd\u6570\u91c7\u7528\u6df7\u5408\u4eff\u5c04-Jacobian\u5750\u6807\u7cfb\u8868\u793a\u70b9\u8ba1\u7b97\u692d\u5706\u66f2\u7ebf\u4e0a\u7684\u52a0\u6cd5","title":"\u51fd\u6570\u8bf4\u660e"},{"location":"tools/muladd/#ecp_add_mixedecpc-1357","text":"static int ecp_add_mixed ( const mbedtls_ecp_group * grp , mbedtls_ecp_point * R , const mbedtls_ecp_point * P , const mbedtls_ecp_point * Q ) { int ret ; mbedtls_mpi T1 , T2 , T3 , T4 , X , Y , Z ; #if defined(MBEDTLS_SELF_TEST) add_count ++ ; #endif #if defined(MBEDTLS_ECP_ADD_MIXED_ALT) if ( mbedtls_internal_ecp_grp_capable ( grp ) ) return ( mbedtls_internal_ecp_add_mixed ( grp , R , P , Q ) ); #endif /* MBEDTLS_ECP_ADD_MIXED_ALT */ /* * Trivial cases: P == 0 or Q == 0 (case 1) */ if ( mbedtls_mpi_cmp_int ( & P -> Z , 0 ) == 0 ) return ( mbedtls_ecp_copy ( R , Q ) ); if ( Q -> Z . p != NULL && mbedtls_mpi_cmp_int ( & Q -> Z , 0 ) == 0 ) return ( mbedtls_ecp_copy ( R , P ) ); /* * Make sure Q coordinates are normalized */ if ( Q -> Z . p != NULL && mbedtls_mpi_cmp_int ( & Q -> Z , 1 ) != 0 ) return ( MBEDTLS_ERR_ECP_BAD_INPUT_DATA ); mbedtls_mpi_init ( & T1 ); mbedtls_mpi_init ( & T2 ); mbedtls_mpi_init ( & T3 ); mbedtls_mpi_init ( & T4 ); mbedtls_mpi_init ( & X ); mbedtls_mpi_init ( & Y ); mbedtls_mpi_init ( & Z ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( & T1 , & P -> Z , & P -> Z ) ); MOD_MUL ( T1 ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( & T2 , & T1 , & P -> Z ) ); MOD_MUL ( T2 ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( & T1 , & T1 , & Q -> X ) ); MOD_MUL ( T1 ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( & T2 , & T2 , & Q -> Y ) ); MOD_MUL ( T2 ); MBEDTLS_MPI_CHK ( mbedtls_mpi_sub_mpi ( & T1 , & T1 , & P -> X ) ); MOD_SUB ( T1 ); MBEDTLS_MPI_CHK ( mbedtls_mpi_sub_mpi ( & T2 , & T2 , & P -> Y ) ); MOD_SUB ( T2 ); /* Special cases (2) and (3) */ if ( mbedtls_mpi_cmp_int ( & T1 , 0 ) == 0 ) { if ( mbedtls_mpi_cmp_int ( & T2 , 0 ) == 0 ) { ret = ecp_double_jac ( grp , R , P ); goto cleanup ; } else { ret = mbedtls_ecp_set_zero ( R ); goto cleanup ; } } MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( & Z , & P -> Z , & T1 ) ); MOD_MUL ( Z ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( & T3 , & T1 , & T1 ) ); MOD_MUL ( T3 ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( & T4 , & T3 , & T1 ) ); MOD_MUL ( T4 ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( & T3 , & T3 , & P -> X ) ); MOD_MUL ( T3 ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_int ( & T1 , & T3 , 2 ) ); MOD_ADD ( T1 ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( & X , & T2 , & T2 ) ); MOD_MUL ( X ); MBEDTLS_MPI_CHK ( mbedtls_mpi_sub_mpi ( & X , & X , & T1 ) ); MOD_SUB ( X ); MBEDTLS_MPI_CHK ( mbedtls_mpi_sub_mpi ( & X , & X , & T4 ) ); MOD_SUB ( X ); MBEDTLS_MPI_CHK ( mbedtls_mpi_sub_mpi ( & T3 , & T3 , & X ) ); MOD_SUB ( T3 ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( & T3 , & T3 , & T2 ) ); MOD_MUL ( T3 ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( & T4 , & T4 , & P -> Y ) ); MOD_MUL ( T4 ); MBEDTLS_MPI_CHK ( mbedtls_mpi_sub_mpi ( & Y , & T3 , & T4 ) ); MOD_SUB ( Y ); MBEDTLS_MPI_CHK ( mbedtls_mpi_copy ( & R -> X , & X ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_copy ( & R -> Y , & Y ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_copy ( & R -> Z , & Z ) ); cleanup : mbedtls_mpi_free ( & T1 ); mbedtls_mpi_free ( & T2 ); mbedtls_mpi_free ( & T3 ); mbedtls_mpi_free ( & T4 ); mbedtls_mpi_free ( & X ); mbedtls_mpi_free ( & Y ); mbedtls_mpi_free ( & Z ); return ( ret ); }","title":"ecp_add_mixed\uff08ecp.c 1357\uff09\u51fd\u6570\u4ee3\u7801"},{"location":"verify/fun3/","text":"\u5165\u53e3\u51fd\u6570\uff1ambedtls_ecdsa_verify\uff08ecdsa.c 597\uff09 \u51fd\u6570\u8f93\u5165 grp\uff1a\u692d\u5706\u66f2\u7ebf\u7fa4\u6307\u9488 buf\uff1a\u6b64\u5904\u8f93\u5165\u4e3a\u6d88\u606fmsg\u7684\u54c8\u5e0c\u503c blen\uff1a\u54c8\u5e0c\u503c\u957f\u5ea6 Q\uff1aECDSA\u5171\u516c\u94a5 r\u3001s\uff1a\u7528\u4e8e\u9a8c\u8bc1\u7684\u7b7e\u540d \u51fd\u6570\u8f93\u51fa ret\uff0c\u8868\u793a\u9a8c\u8bc1\u662f\u5426\u901a\u8fc7\uff0c\u6b63\u786e\u8fd4\u56de0\uff0c\u9519\u8bef\u8fd4\u56deMBEDTLS_ERR_ECP_VERIFY_FAILED \u51fd\u6570\u6d41\u7a0b \u70b9\u51fb\u6d41\u7a0b\u56fe\u8df3\u8f6c\u5bf9\u5e94\u51fd\u6570 graph TB F[mbedtls_ecdsa_verify\u51fd\u6570] A[\u8f93\u5165] -->B(ECDSA_VALIDATE_RET) B -.-> C(ECDSA_VALIDATE_RET) C --> D(ecdsa_verify_restartable) D --> E[\u8f93\u51fa] click B \"../../tools/ECDSA_VALIDATE_RET\" click C \"../../tools/ECDSA_VALIDATE_RET\" click F \"../../tools/ECDSA_VALIDATE_RET\" click D \"../fun4\" \u51fd\u6570\u4ee3\u7801 int mbedtls_ecdsa_verify ( mbedtls_ecp_group * grp , const unsigned char * buf , size_t blen , const mbedtls_ecp_point * Q , const mbedtls_mpi * r , const mbedtls_mpi * s ) { ECDSA_VALIDATE_RET ( grp != NULL ); ECDSA_VALIDATE_RET ( Q != NULL ); ECDSA_VALIDATE_RET ( r != NULL ); ECDSA_VALIDATE_RET ( s != NULL ); ECDSA_VALIDATE_RET ( buf != NULL || blen == 0 ); return ( ecdsa_verify_restartable ( grp , buf , blen , Q , r , s , NULL ) ); } \u51fd\u6570\u8bf4\u660e \u5916\u5c42\u51fd\u6570\u4e0e\u7b7e\u540d\u7c7b\u4f3c\uff0c\u4f20\u9012\u53c2\u6570\u5e76\u8c03\u7528\u6838\u5fc3\u51fd\u6570ecdsa_verify_restartable","title":"mbedtls_ecdsa_verify"},{"location":"verify/fun3/#mbedtls_ecdsa_verifyecdsac-597","text":"","title":"\u5165\u53e3\u51fd\u6570\uff1ambedtls_ecdsa_verify\uff08ecdsa.c 597\uff09"},{"location":"verify/fun3/#_1","text":"grp\uff1a\u692d\u5706\u66f2\u7ebf\u7fa4\u6307\u9488 buf\uff1a\u6b64\u5904\u8f93\u5165\u4e3a\u6d88\u606fmsg\u7684\u54c8\u5e0c\u503c blen\uff1a\u54c8\u5e0c\u503c\u957f\u5ea6 Q\uff1aECDSA\u5171\u516c\u94a5 r\u3001s\uff1a\u7528\u4e8e\u9a8c\u8bc1\u7684\u7b7e\u540d","title":"\u51fd\u6570\u8f93\u5165"},{"location":"verify/fun3/#_2","text":"ret\uff0c\u8868\u793a\u9a8c\u8bc1\u662f\u5426\u901a\u8fc7\uff0c\u6b63\u786e\u8fd4\u56de0\uff0c\u9519\u8bef\u8fd4\u56deMBEDTLS_ERR_ECP_VERIFY_FAILED","title":"\u51fd\u6570\u8f93\u51fa"},{"location":"verify/fun3/#_3","text":"\u70b9\u51fb\u6d41\u7a0b\u56fe\u8df3\u8f6c\u5bf9\u5e94\u51fd\u6570 graph TB F[mbedtls_ecdsa_verify\u51fd\u6570] A[\u8f93\u5165] -->B(ECDSA_VALIDATE_RET) B -.-> C(ECDSA_VALIDATE_RET) C --> D(ecdsa_verify_restartable) D --> E[\u8f93\u51fa] click B \"../../tools/ECDSA_VALIDATE_RET\" click C \"../../tools/ECDSA_VALIDATE_RET\" click F \"../../tools/ECDSA_VALIDATE_RET\" click D \"../fun4\"","title":"\u51fd\u6570\u6d41\u7a0b"},{"location":"verify/fun3/#_4","text":"int mbedtls_ecdsa_verify ( mbedtls_ecp_group * grp , const unsigned char * buf , size_t blen , const mbedtls_ecp_point * Q , const mbedtls_mpi * r , const mbedtls_mpi * s ) { ECDSA_VALIDATE_RET ( grp != NULL ); ECDSA_VALIDATE_RET ( Q != NULL ); ECDSA_VALIDATE_RET ( r != NULL ); ECDSA_VALIDATE_RET ( s != NULL ); ECDSA_VALIDATE_RET ( buf != NULL || blen == 0 ); return ( ecdsa_verify_restartable ( grp , buf , blen , Q , r , s , NULL ) ); }","title":"\u51fd\u6570\u4ee3\u7801"},{"location":"verify/fun3/#_5","text":"\u5916\u5c42\u51fd\u6570\u4e0e\u7b7e\u540d\u7c7b\u4f3c\uff0c\u4f20\u9012\u53c2\u6570\u5e76\u8c03\u7528\u6838\u5fc3\u51fd\u6570ecdsa_verify_restartable","title":"\u51fd\u6570\u8bf4\u660e"},{"location":"verify/fun4/","text":"\u6838\u5fc3\u51fd\u6570ecdsa_verify_restartable\uff08ecdsa.c 489\uff09 \u51fd\u6570\u8f93\u5165 grp\uff1a\u692d\u5706\u66f2\u7ebf\u7fa4\u6307\u9488 buf\uff1a\u6b64\u5904\u8f93\u5165\u4e3a\u6d88\u606fmsg\u7684\u54c8\u5e0c\u503c blen\uff1a\u54c8\u5e0c\u503c\u957f\u5ea6 Q\uff1aECDSA\u5171\u516c\u94a5 r\u3001s\uff1a\u7528\u4e8e\u9a8c\u8bc1\u7684\u7b7e\u540d rs_ctx\uff1arestart\u4e0a\u4e0b\u6587\uff0c\u53d6NULL\u65f6\u7981\u7528\u529f\u80fd \u51fd\u6570\u8f93\u51fa ret\uff0c\u8868\u793a\u9a8c\u8bc1\u662f\u5426\u901a\u8fc7\uff0c\u6b63\u786e\u8fd4\u56de0\uff0c\u9519\u8bef\u8fd4\u56deMBEDTLS_ERR_ECP_VERIFY_FAILED \u51fd\u6570\u6d41\u7a0b \u70b9\u51fb\u6d41\u7a0b\u56fe\u8df3\u8f6c\u5bf9\u5e94\u51fd\u6570 graph TB Z[ecdsa_verify_restartable\u51fd\u6570] A[\u8f93\u5165] -->B(\u5b9a\u4e49\u53d8\u91cf,\u68c0\u67e5\u5408\u6cd5\u6027,\u521d\u59cb\u5316\u7ed3\u6784\u4f53) B --> C(mbedtls_ecp_gen_privkey\u751f\u6210\u968f\u673a\u6570k) C --> D(\u4ece\u54c8\u5e0c\u503c\u751f\u6210\u5927\u6574\u6570e) D --> E(mbedtls_mpi_inv_mod\u8ba1\u7b97s\u9006) E --> G(mbedtls_mpi_mul_mpi\u8ba1\u7b97z*s\u9006) G --> H(mbedtls_mpi_mod_mpi\u5bf9N\u53d6\u6a21) H --> I(mbedtls_mpi_mul_mpi\u8ba1\u7b97r*s\u9006) I --> J(mbedtls_mpi_mod_mpi\u5bf9N\u53d6\u6a21) J --> K(\u5982\u679crestart\u5219\u5b58\u50a8\u72b6\u6001) K --> P(mbedtls_ecp_muladd_restartable\u8ba1\u7b97u1G+u2Q) P --> L(\u53d6R\u7684\u6a2a\u5750\u6807x \u5bf9N\u53d6\u6a21 \u5224\u65ad\u662f\u5426\u4e0e\u7b7e\u540d\u4e2d\u7684r\u90e8\u5206\u76f8\u7b49) L --> M(\u91ca\u653e\u7a7a\u95f4) M --> O(\u8f93\u51fa) click C \"../../tools/mbedtls_ecp_gen_privkey\" click G \"../../tools/mpi\" click E \"../../tools/mpi\" click H \"../../tools/mpi\" click I \"../../tools/mpi\" click J \"../../tools/mpi\" click P \"../../tools/muladd\" \u51fd\u6570\u4ee3\u7801 static int ecdsa_verify_restartable ( mbedtls_ecp_group * grp , const unsigned char * buf , size_t blen , const mbedtls_ecp_point * Q , const mbedtls_mpi * r , const mbedtls_mpi * s , mbedtls_ecdsa_restart_ctx * rs_ctx ) { int ret ; mbedtls_mpi e , s_inv , u1 , u2 ; mbedtls_ecp_point R ; mbedtls_mpi * pu1 = & u1 , * pu2 = & u2 ; mbedtls_ecp_point_init ( & R ); mbedtls_mpi_init ( & e ); mbedtls_mpi_init ( & s_inv ); mbedtls_mpi_init ( & u1 ); mbedtls_mpi_init ( & u2 ); /* Fail cleanly on curves such as Curve25519 that can't be used for ECDSA */ if ( grp -> N . p == NULL ) return ( MBEDTLS_ERR_ECP_BAD_INPUT_DATA ); ECDSA_RS_ENTER ( ver ); #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> ver != NULL ) { /* redirect to our context */ pu1 = & rs_ctx -> ver -> u1 ; pu2 = & rs_ctx -> ver -> u2 ; /* jump to current step */ if ( rs_ctx -> ver -> state == ecdsa_ver_muladd ) goto muladd ; } #endif /* MBEDTLS_ECP_RESTARTABLE */ /* * Step 1: make sure r and s are in range 1..n-1 */ if ( mbedtls_mpi_cmp_int ( r , 1 ) < 0 || mbedtls_mpi_cmp_mpi ( r , & grp -> N ) >= 0 || mbedtls_mpi_cmp_int ( s , 1 ) < 0 || mbedtls_mpi_cmp_mpi ( s , & grp -> N ) >= 0 ) { ret = MBEDTLS_ERR_ECP_VERIFY_FAILED ; goto cleanup ; } /* * Step 3: derive MPI from hashed message */ MBEDTLS_MPI_CHK ( derive_mpi ( grp , & e , buf , blen ) ); /* * Step 4: u1 = e / s mod n, u2 = r / s mod n */ ECDSA_BUDGET ( MBEDTLS_ECP_OPS_CHK + MBEDTLS_ECP_OPS_INV + 2 ); MBEDTLS_MPI_CHK ( mbedtls_mpi_inv_mod ( & s_inv , s , & grp -> N ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( pu1 , & e , & s_inv ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mod_mpi ( pu1 , pu1 , & grp -> N ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( pu2 , r , & s_inv ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mod_mpi ( pu2 , pu2 , & grp -> N ) ); #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> ver != NULL ) rs_ctx -> ver -> state = ecdsa_ver_muladd ; muladd : #endif /* * Step 5: R = u1 G + u2 Q */ MBEDTLS_MPI_CHK ( mbedtls_ecp_muladd_restartable ( grp , & R , pu1 , & grp -> G , pu2 , Q , ECDSA_RS_ECP ) ); if ( mbedtls_ecp_is_zero ( & R ) ) { ret = MBEDTLS_ERR_ECP_VERIFY_FAILED ; goto cleanup ; } /* * Step 6: convert xR to an integer (no-op) * Step 7: reduce xR mod n (gives v) */ MBEDTLS_MPI_CHK ( mbedtls_mpi_mod_mpi ( & R . X , & R . X , & grp -> N ) ); /* * Step 8: check if v (that is, R.X) is equal to r */ if ( mbedtls_mpi_cmp_mpi ( & R . X , r ) != 0 ) { ret = MBEDTLS_ERR_ECP_VERIFY_FAILED ; goto cleanup ; } cleanup : mbedtls_ecp_point_free ( & R ); mbedtls_mpi_free ( & e ); mbedtls_mpi_free ( & s_inv ); mbedtls_mpi_free ( & u1 ); mbedtls_mpi_free ( & u2 ); ECDSA_RS_LEAVE ( ver ); return ( ret ); } \u51fd\u6570\u8bf4\u660e \u8fdb\u884cECDSA\u9a8c\u7b7e \u5bf9\u7167ECDSA\u9a8c\u7b7e\u6d41\u7a0b\uff1a \u7b7e\u540dr\uff0cs \u516c\u94a5Q \u7b2c\u4e00\u6b65 \uff0c\u8ba1\u7b97z=H(msg) \u7b2c\u4e8c\u6b65 \uff0c\u8ba1\u7b97u1=zs^-1 (mod N), u2=rs^-1 (mod N) \u7b2c\u4e09\u6b65 \uff0c\u8ba1\u7b97\u70b9R=u1 G+u2 Q \u7b2c\u56db\u6b65 \uff0c\u9a8c\u8bc1R.x\u662f\u5426\u7b49\u4e8er(mod N) \u4ee3\u7801\u5206\u6790\uff1a\u987a\u5e8f\u5206\u6790\u51fd\u6570\u529f\u80fd int ret ; mbedtls_mpi e , s_inv , u1 , u2 ; mbedtls_ecp_point R ; mbedtls_mpi * pu1 = & u1 , * pu2 = & u2 ; \u5b9a\u4e49\u53d8\u91cf\uff0cu1 u2 R\u4e0e\u4e0a\u9762\u6b65\u9aa4\u4e2d\u7684u1 u2 R\u5bf9\u5e94\uff0cret\u7528\u4e8e\u5b58\u50a8\u7ed3\u679c\uff0cs_inv\u5b58\u50a8s^-1\u7684\u503c\uff0ce\u5b58\u50a8\u54c8\u5e0c\u751f\u6210\u7684\u5927\u6574\u6570 mbedtls_ecp_point_init ( & R ); mbedtls_mpi_init ( & e ); mbedtls_mpi_init ( & s_inv ); mbedtls_mpi_init ( & u1 ); mbedtls_mpi_init ( & u2 ); /* Fail cleanly on curves such as Curve25519 that can't be used for ECDSA */ if ( grp -> N . p == NULL ) return ( MBEDTLS_ERR_ECP_BAD_INPUT_DATA ); \u521d\u59cb\u5316\u7ed3\u6784\u4f53\u5e76\u68c0\u67e5\u5408\u6cd5\u6027\uff08\u5224\u65adN\u662f\u5426\u4e3a\u7a7a\uff09 ECDSA_RS_ENTER ( ver ); #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> ver != NULL ) { /* redirect to our context */ pu1 = & rs_ctx -> ver -> u1 ; pu2 = & rs_ctx -> ver -> u2 ; /* jump to current step */ if ( rs_ctx -> ver -> state == ecdsa_ver_muladd ) goto muladd ; } #endif /* MBEDTLS_ECP_RESTARTABLE */ \u7c7b\u4f3c\u5730\uff0c\u5982\u679c\u5f00\u542f\u4e86restart\u6a21\u5f0f\uff0c\u4e3au1 u2\u8d4b\u503c\u5e76\u8df3\u8f6c\u5230\u5bf9\u5e94\u7684\u4f4d\u7f6e\u7ee7\u7eed\u6267\u884c if ( mbedtls_mpi_cmp_int ( r , 1 ) < 0 || mbedtls_mpi_cmp_mpi ( r , & grp -> N ) >= 0 || mbedtls_mpi_cmp_int ( s , 1 ) < 0 || mbedtls_mpi_cmp_mpi ( s , & grp -> N ) >= 0 ) { ret = MBEDTLS_ERR_ECP_VERIFY_FAILED ; goto cleanup ; } \u68c0\u67e5\u7b7e\u540d\uff08r,s\uff09\u662f\u5426\u5408\u7406\uff0c\u5224\u65ad\u662f\u5426\u57281\u5230n-1\u7684\u8303\u56f4\u5185 MBEDTLS_MPI_CHK ( derive_mpi ( grp , & e , buf , blen ) ); \u4ece\u54c8\u5e0c\u503cbuf\u751f\u6210\u5bf9\u5e94\u7684\u5927\u6574\u6570e MBEDTLS_MPI_CHK ( mbedtls_mpi_inv_mod ( & s_inv , s , & grp -> N ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( pu1 , & e , & s_inv ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mod_mpi ( pu1 , pu1 , & grp -> N ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( pu2 , r , & s_inv ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mod_mpi ( pu2 , pu2 , & grp -> N ) ); \u4e0e\u4e0a\u9762\u7684\u6d41\u7a0b\u5bf9\u5e94\uff0c\u8ba1\u7b97u1=zs^-1 (mod N), u2=rs^-1 (mod N) #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> ver != NULL ) rs_ctx -> ver -> state = ecdsa_ver_muladd ; muladd : #endif \u8fd9\u91cc\u5982\u679c\u5f00\u542f\u4e86restart\u6a21\u5f0f\uff0c\u5219\u8fdb\u884c\u72b6\u6001\u5b58\u50a8rs_ctx->ver->state = ecdsa_ver_muladd\uff0c\u540c\u65f6\u65ad\u70b9\u7ee7\u7eed\u6267\u884c\u65f6\u4e5f\u4ece\u8fd9\u4e00\u53e5\u4e0b\u9762\u7684muladd\uff1a\u540e\u5f00\u59cb\u6267\u884c MBEDTLS_MPI_CHK ( mbedtls_ecp_muladd_restartable ( grp , & R , pu1 , & grp -> G , pu2 , Q , ECDSA_RS_ECP ) ); \u4f7f\u7528mbedtls_ecp_muladd_restartable\u51fd\u6570\u8ba1\u7b97R = u1 G + u2 Q if ( mbedtls_ecp_is_zero ( & R ) ) { ret = MBEDTLS_ERR_ECP_VERIFY_FAILED ; goto cleanup ; } MBEDTLS_MPI_CHK ( mbedtls_mpi_mod_mpi ( & R . X , & R . X , & grp -> N ) ); if ( mbedtls_mpi_cmp_mpi ( & R . X , r ) != 0 ) { ret = MBEDTLS_ERR_ECP_VERIFY_FAILED ; goto cleanup ; } \u5148\u5224\u65ad\u8ba1\u7b97\u5f97\u5230\u7684\u70b9R\u662f\u5426\u4e3a\u96f6\uff0c\u5982\u679c\u4e3a\u96f6\u5219\u5931\u8d25\u3002 \u4e4b\u540e\u53d6R\u7684\u6a2a\u5750\u6807x\uff0c\u5bf9N\u53d6\u6a21\uff0c\u5224\u65ad\u662f\u5426\u4e0e\u7b7e\u540d\u4e2d\u7684r\u90e8\u5206\u76f8\u7b49\uff0c\u5982\u679c\u76f8\u7b49\u5219\u9a8c\u7b7e\u901a\u8fc7 cleanup : mbedtls_ecp_point_free ( & R ); mbedtls_mpi_free ( & e ); mbedtls_mpi_free ( & s_inv ); mbedtls_mpi_free ( & u1 ); mbedtls_mpi_free ( & u2 ); ECDSA_RS_LEAVE ( ver ); return ( ret ); \u6700\u540e\u91ca\u653e\u7a7a\u95f4\u5e76\u8fd4\u56de","title":"ecdsa_verify_restartable"},{"location":"verify/fun4/#ecdsa_verify_restartableecdsac-489","text":"","title":"\u6838\u5fc3\u51fd\u6570ecdsa_verify_restartable\uff08ecdsa.c 489\uff09"},{"location":"verify/fun4/#_1","text":"grp\uff1a\u692d\u5706\u66f2\u7ebf\u7fa4\u6307\u9488 buf\uff1a\u6b64\u5904\u8f93\u5165\u4e3a\u6d88\u606fmsg\u7684\u54c8\u5e0c\u503c blen\uff1a\u54c8\u5e0c\u503c\u957f\u5ea6 Q\uff1aECDSA\u5171\u516c\u94a5 r\u3001s\uff1a\u7528\u4e8e\u9a8c\u8bc1\u7684\u7b7e\u540d rs_ctx\uff1arestart\u4e0a\u4e0b\u6587\uff0c\u53d6NULL\u65f6\u7981\u7528\u529f\u80fd","title":"\u51fd\u6570\u8f93\u5165"},{"location":"verify/fun4/#_2","text":"ret\uff0c\u8868\u793a\u9a8c\u8bc1\u662f\u5426\u901a\u8fc7\uff0c\u6b63\u786e\u8fd4\u56de0\uff0c\u9519\u8bef\u8fd4\u56deMBEDTLS_ERR_ECP_VERIFY_FAILED","title":"\u51fd\u6570\u8f93\u51fa"},{"location":"verify/fun4/#_3","text":"\u70b9\u51fb\u6d41\u7a0b\u56fe\u8df3\u8f6c\u5bf9\u5e94\u51fd\u6570 graph TB Z[ecdsa_verify_restartable\u51fd\u6570] A[\u8f93\u5165] -->B(\u5b9a\u4e49\u53d8\u91cf,\u68c0\u67e5\u5408\u6cd5\u6027,\u521d\u59cb\u5316\u7ed3\u6784\u4f53) B --> C(mbedtls_ecp_gen_privkey\u751f\u6210\u968f\u673a\u6570k) C --> D(\u4ece\u54c8\u5e0c\u503c\u751f\u6210\u5927\u6574\u6570e) D --> E(mbedtls_mpi_inv_mod\u8ba1\u7b97s\u9006) E --> G(mbedtls_mpi_mul_mpi\u8ba1\u7b97z*s\u9006) G --> H(mbedtls_mpi_mod_mpi\u5bf9N\u53d6\u6a21) H --> I(mbedtls_mpi_mul_mpi\u8ba1\u7b97r*s\u9006) I --> J(mbedtls_mpi_mod_mpi\u5bf9N\u53d6\u6a21) J --> K(\u5982\u679crestart\u5219\u5b58\u50a8\u72b6\u6001) K --> P(mbedtls_ecp_muladd_restartable\u8ba1\u7b97u1G+u2Q) P --> L(\u53d6R\u7684\u6a2a\u5750\u6807x \u5bf9N\u53d6\u6a21 \u5224\u65ad\u662f\u5426\u4e0e\u7b7e\u540d\u4e2d\u7684r\u90e8\u5206\u76f8\u7b49) L --> M(\u91ca\u653e\u7a7a\u95f4) M --> O(\u8f93\u51fa) click C \"../../tools/mbedtls_ecp_gen_privkey\" click G \"../../tools/mpi\" click E \"../../tools/mpi\" click H \"../../tools/mpi\" click I \"../../tools/mpi\" click J \"../../tools/mpi\" click P \"../../tools/muladd\"","title":"\u51fd\u6570\u6d41\u7a0b"},{"location":"verify/fun4/#_4","text":"","title":""},{"location":"verify/fun4/#_5","text":"static int ecdsa_verify_restartable ( mbedtls_ecp_group * grp , const unsigned char * buf , size_t blen , const mbedtls_ecp_point * Q , const mbedtls_mpi * r , const mbedtls_mpi * s , mbedtls_ecdsa_restart_ctx * rs_ctx ) { int ret ; mbedtls_mpi e , s_inv , u1 , u2 ; mbedtls_ecp_point R ; mbedtls_mpi * pu1 = & u1 , * pu2 = & u2 ; mbedtls_ecp_point_init ( & R ); mbedtls_mpi_init ( & e ); mbedtls_mpi_init ( & s_inv ); mbedtls_mpi_init ( & u1 ); mbedtls_mpi_init ( & u2 ); /* Fail cleanly on curves such as Curve25519 that can't be used for ECDSA */ if ( grp -> N . p == NULL ) return ( MBEDTLS_ERR_ECP_BAD_INPUT_DATA ); ECDSA_RS_ENTER ( ver ); #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> ver != NULL ) { /* redirect to our context */ pu1 = & rs_ctx -> ver -> u1 ; pu2 = & rs_ctx -> ver -> u2 ; /* jump to current step */ if ( rs_ctx -> ver -> state == ecdsa_ver_muladd ) goto muladd ; } #endif /* MBEDTLS_ECP_RESTARTABLE */ /* * Step 1: make sure r and s are in range 1..n-1 */ if ( mbedtls_mpi_cmp_int ( r , 1 ) < 0 || mbedtls_mpi_cmp_mpi ( r , & grp -> N ) >= 0 || mbedtls_mpi_cmp_int ( s , 1 ) < 0 || mbedtls_mpi_cmp_mpi ( s , & grp -> N ) >= 0 ) { ret = MBEDTLS_ERR_ECP_VERIFY_FAILED ; goto cleanup ; } /* * Step 3: derive MPI from hashed message */ MBEDTLS_MPI_CHK ( derive_mpi ( grp , & e , buf , blen ) ); /* * Step 4: u1 = e / s mod n, u2 = r / s mod n */ ECDSA_BUDGET ( MBEDTLS_ECP_OPS_CHK + MBEDTLS_ECP_OPS_INV + 2 ); MBEDTLS_MPI_CHK ( mbedtls_mpi_inv_mod ( & s_inv , s , & grp -> N ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( pu1 , & e , & s_inv ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mod_mpi ( pu1 , pu1 , & grp -> N ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( pu2 , r , & s_inv ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mod_mpi ( pu2 , pu2 , & grp -> N ) ); #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> ver != NULL ) rs_ctx -> ver -> state = ecdsa_ver_muladd ; muladd : #endif /* * Step 5: R = u1 G + u2 Q */ MBEDTLS_MPI_CHK ( mbedtls_ecp_muladd_restartable ( grp , & R , pu1 , & grp -> G , pu2 , Q , ECDSA_RS_ECP ) ); if ( mbedtls_ecp_is_zero ( & R ) ) { ret = MBEDTLS_ERR_ECP_VERIFY_FAILED ; goto cleanup ; } /* * Step 6: convert xR to an integer (no-op) * Step 7: reduce xR mod n (gives v) */ MBEDTLS_MPI_CHK ( mbedtls_mpi_mod_mpi ( & R . X , & R . X , & grp -> N ) ); /* * Step 8: check if v (that is, R.X) is equal to r */ if ( mbedtls_mpi_cmp_mpi ( & R . X , r ) != 0 ) { ret = MBEDTLS_ERR_ECP_VERIFY_FAILED ; goto cleanup ; } cleanup : mbedtls_ecp_point_free ( & R ); mbedtls_mpi_free ( & e ); mbedtls_mpi_free ( & s_inv ); mbedtls_mpi_free ( & u1 ); mbedtls_mpi_free ( & u2 ); ECDSA_RS_LEAVE ( ver ); return ( ret ); }","title":"\u51fd\u6570\u4ee3\u7801"},{"location":"verify/fun4/#_6","text":"\u8fdb\u884cECDSA\u9a8c\u7b7e \u5bf9\u7167ECDSA\u9a8c\u7b7e\u6d41\u7a0b\uff1a \u7b7e\u540dr\uff0cs \u516c\u94a5Q \u7b2c\u4e00\u6b65 \uff0c\u8ba1\u7b97z=H(msg) \u7b2c\u4e8c\u6b65 \uff0c\u8ba1\u7b97u1=zs^-1 (mod N), u2=rs^-1 (mod N) \u7b2c\u4e09\u6b65 \uff0c\u8ba1\u7b97\u70b9R=u1 G+u2 Q \u7b2c\u56db\u6b65 \uff0c\u9a8c\u8bc1R.x\u662f\u5426\u7b49\u4e8er(mod N) \u4ee3\u7801\u5206\u6790\uff1a\u987a\u5e8f\u5206\u6790\u51fd\u6570\u529f\u80fd int ret ; mbedtls_mpi e , s_inv , u1 , u2 ; mbedtls_ecp_point R ; mbedtls_mpi * pu1 = & u1 , * pu2 = & u2 ; \u5b9a\u4e49\u53d8\u91cf\uff0cu1 u2 R\u4e0e\u4e0a\u9762\u6b65\u9aa4\u4e2d\u7684u1 u2 R\u5bf9\u5e94\uff0cret\u7528\u4e8e\u5b58\u50a8\u7ed3\u679c\uff0cs_inv\u5b58\u50a8s^-1\u7684\u503c\uff0ce\u5b58\u50a8\u54c8\u5e0c\u751f\u6210\u7684\u5927\u6574\u6570 mbedtls_ecp_point_init ( & R ); mbedtls_mpi_init ( & e ); mbedtls_mpi_init ( & s_inv ); mbedtls_mpi_init ( & u1 ); mbedtls_mpi_init ( & u2 ); /* Fail cleanly on curves such as Curve25519 that can't be used for ECDSA */ if ( grp -> N . p == NULL ) return ( MBEDTLS_ERR_ECP_BAD_INPUT_DATA ); \u521d\u59cb\u5316\u7ed3\u6784\u4f53\u5e76\u68c0\u67e5\u5408\u6cd5\u6027\uff08\u5224\u65adN\u662f\u5426\u4e3a\u7a7a\uff09 ECDSA_RS_ENTER ( ver ); #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> ver != NULL ) { /* redirect to our context */ pu1 = & rs_ctx -> ver -> u1 ; pu2 = & rs_ctx -> ver -> u2 ; /* jump to current step */ if ( rs_ctx -> ver -> state == ecdsa_ver_muladd ) goto muladd ; } #endif /* MBEDTLS_ECP_RESTARTABLE */ \u7c7b\u4f3c\u5730\uff0c\u5982\u679c\u5f00\u542f\u4e86restart\u6a21\u5f0f\uff0c\u4e3au1 u2\u8d4b\u503c\u5e76\u8df3\u8f6c\u5230\u5bf9\u5e94\u7684\u4f4d\u7f6e\u7ee7\u7eed\u6267\u884c if ( mbedtls_mpi_cmp_int ( r , 1 ) < 0 || mbedtls_mpi_cmp_mpi ( r , & grp -> N ) >= 0 || mbedtls_mpi_cmp_int ( s , 1 ) < 0 || mbedtls_mpi_cmp_mpi ( s , & grp -> N ) >= 0 ) { ret = MBEDTLS_ERR_ECP_VERIFY_FAILED ; goto cleanup ; } \u68c0\u67e5\u7b7e\u540d\uff08r,s\uff09\u662f\u5426\u5408\u7406\uff0c\u5224\u65ad\u662f\u5426\u57281\u5230n-1\u7684\u8303\u56f4\u5185 MBEDTLS_MPI_CHK ( derive_mpi ( grp , & e , buf , blen ) ); \u4ece\u54c8\u5e0c\u503cbuf\u751f\u6210\u5bf9\u5e94\u7684\u5927\u6574\u6570e MBEDTLS_MPI_CHK ( mbedtls_mpi_inv_mod ( & s_inv , s , & grp -> N ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( pu1 , & e , & s_inv ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mod_mpi ( pu1 , pu1 , & grp -> N ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mul_mpi ( pu2 , r , & s_inv ) ); MBEDTLS_MPI_CHK ( mbedtls_mpi_mod_mpi ( pu2 , pu2 , & grp -> N ) ); \u4e0e\u4e0a\u9762\u7684\u6d41\u7a0b\u5bf9\u5e94\uff0c\u8ba1\u7b97u1=zs^-1 (mod N), u2=rs^-1 (mod N) #if defined(MBEDTLS_ECP_RESTARTABLE) if ( rs_ctx != NULL && rs_ctx -> ver != NULL ) rs_ctx -> ver -> state = ecdsa_ver_muladd ; muladd : #endif \u8fd9\u91cc\u5982\u679c\u5f00\u542f\u4e86restart\u6a21\u5f0f\uff0c\u5219\u8fdb\u884c\u72b6\u6001\u5b58\u50a8rs_ctx->ver->state = ecdsa_ver_muladd\uff0c\u540c\u65f6\u65ad\u70b9\u7ee7\u7eed\u6267\u884c\u65f6\u4e5f\u4ece\u8fd9\u4e00\u53e5\u4e0b\u9762\u7684muladd\uff1a\u540e\u5f00\u59cb\u6267\u884c MBEDTLS_MPI_CHK ( mbedtls_ecp_muladd_restartable ( grp , & R , pu1 , & grp -> G , pu2 , Q , ECDSA_RS_ECP ) ); \u4f7f\u7528mbedtls_ecp_muladd_restartable\u51fd\u6570\u8ba1\u7b97R = u1 G + u2 Q if ( mbedtls_ecp_is_zero ( & R ) ) { ret = MBEDTLS_ERR_ECP_VERIFY_FAILED ; goto cleanup ; } MBEDTLS_MPI_CHK ( mbedtls_mpi_mod_mpi ( & R . X , & R . X , & grp -> N ) ); if ( mbedtls_mpi_cmp_mpi ( & R . X , r ) != 0 ) { ret = MBEDTLS_ERR_ECP_VERIFY_FAILED ; goto cleanup ; } \u5148\u5224\u65ad\u8ba1\u7b97\u5f97\u5230\u7684\u70b9R\u662f\u5426\u4e3a\u96f6\uff0c\u5982\u679c\u4e3a\u96f6\u5219\u5931\u8d25\u3002 \u4e4b\u540e\u53d6R\u7684\u6a2a\u5750\u6807x\uff0c\u5bf9N\u53d6\u6a21\uff0c\u5224\u65ad\u662f\u5426\u4e0e\u7b7e\u540d\u4e2d\u7684r\u90e8\u5206\u76f8\u7b49\uff0c\u5982\u679c\u76f8\u7b49\u5219\u9a8c\u7b7e\u901a\u8fc7 cleanup : mbedtls_ecp_point_free ( & R ); mbedtls_mpi_free ( & e ); mbedtls_mpi_free ( & s_inv ); mbedtls_mpi_free ( & u1 ); mbedtls_mpi_free ( & u2 ); ECDSA_RS_LEAVE ( ver ); return ( ret ); \u6700\u540e\u91ca\u653e\u7a7a\u95f4\u5e76\u8fd4\u56de","title":"\u51fd\u6570\u8bf4\u660e"}]}